!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.15 (master) - 15 Apr 2020 11:54
!
MODULE THREE_EQUATION_B
  USE ISO_C_BINDING
  IMPLICIT NONE
  REAL*8, PARAMETER :: eps=1e-15, log10eps=1.0000000000000022, expit_lim&
& = 709.7

CONTAINS
  SUBROUTINE UWQ(qx, qy, qz, mtosys, u, w, qe)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: qx(4), qy(4), qz(4), mtosys(3, 3)
    REAL*8, INTENT(OUT) :: u(4), w(4), qe(4)
    INTRINSIC SQRT
    qe = SQRT(qx**2 + qy**2 + qz**2)
    u = mtosys(1, 1)*qx + mtosys(1, 2)*qy + mtosys(1, 3)*qz
    w = mtosys(3, 1)*qx + mtosys(3, 2)*qy + mtosys(3, 3)*qz
  END SUBROUTINE UWQ

  SUBROUTINE MACHE(qe, v_sonic, m)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: qe(4), v_sonic
    REAL*8, INTENT(OUT) :: m(4)
    m = qe/v_sonic
  END SUBROUTINE MACHE

  SUBROUTINE RHOE(m, a, rho0, uinf, rho)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: m(4), a, rho0, uinf
    REAL*8, INTENT(OUT) :: rho(4)
    rho = (1.0-m**2*(m*a-uinf)/uinf)*rho0
  END SUBROUTINE RHOE

!  Differentiation of reth in reverse (adjoint) mode:
!   gradient     of useful results: re th11
!   with respect to varying inputs: th11
  SUBROUTINE RETH_B(qe, rho, th11, th11b, mu, re, reb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: qe(4), rho(4), th11(4), mu
    REAL*8 :: th11b(4)
    REAL*8 :: re(4)
    REAL*8 :: reb(4)
    INTEGER :: i
    INTEGER :: branch
    re = qe*rho*th11/mu
    DO i=1,4
      IF (re(i) .LT. log10eps) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    DO i=4,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) reb(i) = 0.0_8
    END DO
    th11b = th11b + qe*rho*reb/mu
  END SUBROUTINE RETH_B

  SUBROUTINE RETH(qe, rho, th11, mu, re)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: qe(4), rho(4), th11(4), mu
    REAL*8, INTENT(OUT) :: re(4)
    INTEGER :: i
    re = qe*rho*th11/mu
    DO i=1,4
      IF (re(i) .LT. log10eps) re(i) = log10eps
    END DO
  END SUBROUTINE RETH

!  Differentiation of expit in reverse (adjoint) mode:
!   gradient     of useful results: sig
!   with respect to varying inputs: x
  SUBROUTINE EXPIT_B(x, xb, n, sig, sigb)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    REAL*8, INTENT(IN) :: x(n)
    REAL*8 :: xb(n)
    REAL*8 :: sig(n)
    REAL*8 :: sigb(n)
    INTEGER :: i
    INTRINSIC EXP
    REAL*8 :: temp
    INTEGER :: branch
    DO i=1,n
      IF (x(i) .LT. -expit_lim) THEN
        CALL PUSHCONTROL2B(2)
      ELSE IF (x(i) .GT. expit_lim) THEN
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
    xb = 0.0_8
    DO i=n,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        temp = EXP(-x(i)) + 1.0
        xb(i) = xb(i) + EXP(-x(i))*sigb(i)/temp**2
        sigb(i) = 0.0_8
      ELSE IF (branch .EQ. 1) THEN
        sigb(i) = 0.0_8
      ELSE
        sigb(i) = 0.0_8
      END IF
    END DO
  END SUBROUTINE EXPIT_B

  SUBROUTINE EXPIT(x, n, sig)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    REAL*8, INTENT(IN) :: x(n)
    REAL*8, INTENT(OUT) :: sig(n)
    INTEGER :: i
    INTRINSIC EXP
    DO i=1,n
      IF (x(i) .LT. -expit_lim) THEN
        sig(i) = 0.0
      ELSE IF (x(i) .GT. expit_lim) THEN
        sig(i) = 1.0
      ELSE
        sig(i) = 1.0/(1.0+EXP(-x(i)))
      END IF
    END DO
  END SUBROUTINE EXPIT

!  Differentiation of rethcrit in reverse (adjoint) mode:
!   gradient     of useful results: hk rethc
!   with respect to varying inputs: hk
  SUBROUTINE RETHCRIT_B(hk, hkb, rethc, rethcb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4)
    REAL*8 :: hkb(4)
    REAL*8 :: rethc(4)
    REAL*8 :: rethcb(4)
    INTRINSIC TANH
    REAL*8, DIMENSION(4) :: temp
    REAL*8, DIMENSION(4) :: temp0
    REAL*8, DIMENSION(4) :: temp1
    REAL*8, DIMENSION(4) :: tempb
    temp = 20.0/(hk-1.0)
    temp0 = TANH(temp - 12.9)
    temp1 = 1.415/(hk-1.0)
    tempb = 10.0**(3.295/(hk-1.0)+(temp1-0.489)*temp0+0.44)*LOG(10.0)*&
&     rethcb
    hkb = hkb - (3.295/(hk-1.0)**2+temp1*temp0/(hk-1.0)+temp*(1.0-TANH(&
&     temp-12.9)**2)*(temp1-0.489)/(hk-1.0))*tempb
  END SUBROUTINE RETHCRIT_B

  SUBROUTINE RETHCRIT(hk, rethc)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4)
    REAL*8, INTENT(OUT) :: rethc(4)
    INTRINSIC TANH
    rethc = 10.0**(3.295/(hk-1.0)+0.44+(1.415/(hk-1.0)-0.489)*TANH(20.0/&
&     (hk-1.0)-12.9))
  END SUBROUTINE RETHCRIT

!  Differentiation of dndreth in reverse (adjoint) mode:
!   gradient     of useful results: dndr hk rth
!   with respect to varying inputs: hk rth rethc
  SUBROUTINE DNDRETH_B(rethc, rethcb, rth, rthb, hk, hkb, a, dndr, dndrb&
& )
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: rethc(4), rth(4), hk(4), a
    REAL*8 :: rethcb(4), rthb(4), hkb(4)
    REAL*8 :: dndr(4)
    REAL*8 :: dndrb(4)
    REAL*8 :: sg(4)
    REAL*8 :: sgb(4)
    INTRINSIC TANH
    INTRINSIC SQRT
    REAL*8, DIMENSION(4) :: arg1
    REAL*8, DIMENSION(4) :: arg1b
    REAL*8, DIMENSION(4) :: temp
    REAL*8, DIMENSION(4) :: temp0
    REAL*8, DIMENSION(4) :: tempb
    arg1(:) = a*(rth-rethc)
    CALL EXPIT(arg1(:), 4, sg)
    sgb = 0.0_8
    temp = 2.4*hk + 2.5*TANH(1.5*hk-4.65) - 3.7
    temp0 = SQRT(temp*temp + 0.15)
    WHERE (temp**2 + 0.15 .EQ. 0.0) 
      tempb = 0.0_8
    ELSEWHERE
      tempb = 2*temp*sg*0.01*dndrb/(2.0*temp0)
    END WHERE
    sgb = temp0*0.01*dndrb
    hkb = hkb + (1.5*(1.0-TANH(1.5*hk-4.65)**2)*2.5+2.4)*tempb
    CALL EXPIT_B(arg1(:), arg1b(:), 4, sg, sgb)
    rethcb = 0.0_8
    rthb = rthb + a*arg1b
    rethcb = -(a*arg1b(:))
  END SUBROUTINE DNDRETH_B

  SUBROUTINE DNDRETH(rethc, rth, hk, a, dndr)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: rethc(4), rth(4), hk(4), a
    REAL*8, INTENT(OUT) :: dndr(4)
    REAL*8 :: sg(4)
    INTRINSIC TANH
    INTRINSIC SQRT
    REAL*8, DIMENSION(4) :: arg1
    arg1(:) = a*(rth-rethc)
    CALL EXPIT(arg1(:), 4, sg)
    dndr = 0.01*SQRT((2.4*hk-3.7+2.5*TANH(1.5*hk-4.65))**2+0.15)*sg
  END SUBROUTINE DNDRETH

!  Differentiation of p_trans in reverse (adjoint) mode:
!   gradient     of useful results: p hk rth th11
!   with respect to varying inputs: hk rth th11
  SUBROUTINE P_TRANS_B(rth, rthb, hk, hkb, th11, th11b, a, p, pb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: rth(4), hk(4), th11(4), a
    REAL*8 :: rthb(4), hkb(4), th11b(4)
    REAL*8 :: p(4)
    REAL*8 :: pb(4)
    REAL*8 :: rthc(4), dndr(4), m(4), l(4)
    REAL*8 :: rthcb(4), dndrb(4), mb(4), lb(4)
    REAL*8, DIMENSION(4) :: temp
    REAL*8, DIMENSION(4) :: tempb
    CALL RETHCRIT(hk, rthc)
    CALL DNDRETH(rthc, rth, hk, a, dndr)
    l = (6.54*hk-14.07)/hk**2
    m = (0.058*(hk-4.0)**2/(hk-1.0)-0.068)/l
    lb = 0.0_8
    mb = 0.0_8
    dndrb = 0.0_8
    temp = (m+1.0)/(2*th11)
    dndrb = l*temp*pb
    lb = dndr*temp*pb
    tempb = dndr*l*pb/(2*th11)
    mb = tempb
    th11b = th11b - 2*temp*tempb
    temp = (hk-4.0)*(hk-4.0)/(hk-1.0)
    tempb = 0.058*mb/((hk-1.0)*l)
    lb = lb - (0.058*temp-0.068)*mb/l**2
    hkb = hkb + (2*hk-2*4.0-temp)*tempb
    tempb = lb/hk**2
    hkb = hkb + (6.54-2*(6.54*hk-14.07)/hk)*tempb
    CALL DNDRETH_B(rthc, rthcb, rth, rthb, hk, hkb, a, dndr, dndrb)
    CALL RETHCRIT_B(hk, hkb, rthc, rthcb)
  END SUBROUTINE P_TRANS_B

  SUBROUTINE P_TRANS(rth, hk, th11, a, p)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: rth(4), hk(4), th11(4), a
    REAL*8, INTENT(OUT) :: p(4)
    REAL*8 :: rthc(4), dndr(4), m(4), l(4)
    CALL RETHCRIT(hk, rthc)
    CALL DNDRETH(rthc, rth, hk, a, dndr)
    l = (6.54*hk-14.07)/hk**2
    m = (0.058*(hk-4.0)**2/(hk-1.0)-0.068)/l
    p = dndr*((m+1.0)/2)*l/th11
  END SUBROUTINE P_TRANS

!  Differentiation of hk_closure in reverse (adjoint) mode:
!   gradient     of useful results: h hk
!   with respect to varying inputs: h
  SUBROUTINE HK_CLOSURE_B(h, hb, me, hk, hkb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: h(4), me(4)
    REAL*8 :: hb(4)
    REAL*8 :: hk(4)
    REAL*8 :: hkb(4)
    hb = hb + hkb/(me**2*0.113+1.0)
  END SUBROUTINE HK_CLOSURE_B

  SUBROUTINE HK_CLOSURE(h, me, hk)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: h(4), me(4)
    REAL*8, INTENT(OUT) :: hk(4)
    hk = (h-0.290*me**2)/(1.0+0.113*me**2)
  END SUBROUTINE HK_CLOSURE

!  Differentiation of hstar_laminar in reverse (adjoint) mode:
!   gradient     of useful results: hst hk
!   with respect to varying inputs: hst hk
  SUBROUTINE HSTAR_LAMINAR_B(hk, hkb, hst, hstb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4)
    REAL*8 :: hkb(4)
    REAL*8 :: hst(4)
    REAL*8 :: hstb(4)
    INTEGER :: i
    REAL*8 :: tempb
    INTEGER :: branch
    DO i=1,4
      IF (hk(i) .LT. 4.0) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    DO i=4,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        tempb = 0.04*hstb(i)/hk(i)
        hstb(i) = 0.0_8
        hkb(i) = hkb(i) + (2*hk(i)-2*4.0-(hk(i)-4.0)**2/hk(i))*tempb
      ELSE
        tempb = 0.076*hstb(i)/hk(i)
        hstb(i) = 0.0_8
        hkb(i) = hkb(i) - (2*4.0-2*hk(i)+(4.0-hk(i))**2/hk(i))*tempb
      END IF
    END DO
  END SUBROUTINE HSTAR_LAMINAR_B

  SUBROUTINE HSTAR_LAMINAR(hk, hst)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4)
    REAL*8, INTENT(OUT) :: hst(4)
    INTEGER :: i
    DO i=1,4
      IF (hk(i) .LT. 4.0) THEN
        hst(i) = 0.076*(4.0-hk(i))**2/hk(i) + 1.515
      ELSE
        hst(i) = 0.04*(hk(i)-4.0)**2/hk(i) + 1.515
      END IF
    END DO
  END SUBROUTINE HSTAR_LAMINAR

!  Differentiation of cf_laminar in reverse (adjoint) mode:
!   gradient     of useful results: hk rth cf
!   with respect to varying inputs: hk rth
  SUBROUTINE CF_LAMINAR_B(hk, hkb, rth, rthb, cf, cfb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), rth(4)
    REAL*8 :: hkb(4), rthb(4)
    REAL*8 :: cf(4)
    REAL*8 :: cfb(4)
    REAL*8 :: tau(4)
    REAL*8 :: taub(4)
    INTEGER :: i
    REAL*8 :: temp
    REAL*8 :: tempb
    INTEGER :: branch
    DO i=1,4
      IF (hk(i) .LT. 7.4) THEN
        tau(i) = 0.0396*(7.4-hk(i))**2/(hk(i)-1.0) - 0.134
        CALL PUSHCONTROL1B(1)
      ELSE
        tau(i) = 0.044*(1.0-1.4/(hk(i)-6.0))**2 - 0.134
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    taub = 0.0_8
    taub = cfb/rth
    rthb = rthb - tau*cfb/rth**2
    DO i=4,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        temp = 1.4/(hk(i)-6.0)
        hkb(i) = hkb(i) + temp*2*(1.0-temp)*0.044*taub(i)/(hk(i)-6.0)
        taub(i) = 0.0_8
      ELSE
        tempb = 0.0396*taub(i)/(hk(i)-1.0)
        taub(i) = 0.0_8
        hkb(i) = hkb(i) - (2*7.4-2*hk(i)+(7.4-hk(i))**2/(hk(i)-1.0))*&
&         tempb
      END IF
    END DO
  END SUBROUTINE CF_LAMINAR_B

  SUBROUTINE CF_LAMINAR(hk, rth, cf)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), rth(4)
    REAL*8, INTENT(OUT) :: cf(4)
    REAL*8 :: tau(4)
    INTEGER :: i
    DO i=1,4
      IF (hk(i) .LT. 7.4) THEN
        tau(i) = 0.0396*(7.4-hk(i))**2/(hk(i)-1.0) - 0.134
      ELSE
        tau(i) = 0.044*(1.0-1.4/(hk(i)-6.0))**2 - 0.134
      END IF
    END DO
    cf = tau/rth
  END SUBROUTINE CF_LAMINAR

!  Differentiation of hprime_laminar in reverse (adjoint) mode:
!   gradient     of useful results: hpr hk
!   with respect to varying inputs: hk
  SUBROUTINE HPRIME_LAMINAR_B(me, hk, hkb, hpr, hprb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: me(4), hk(4)
    REAL*8 :: hkb(4)
    REAL*8 :: hpr(4)
    REAL*8 :: hprb(4)
    hkb = hkb - 0.064*me**2*hprb/(hk-0.8)**2
  END SUBROUTINE HPRIME_LAMINAR_B

  SUBROUTINE HPRIME_LAMINAR(me, hk, hpr)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: me(4), hk(4)
    REAL*8, INTENT(OUT) :: hpr(4)
    hpr = me**2*(0.251+0.064/(hk-0.8))
  END SUBROUTINE HPRIME_LAMINAR

!  Differentiation of cd_laminar in reverse (adjoint) mode:
!   gradient     of useful results: hst hk rth cd
!   with respect to varying inputs: hst hk rth
  SUBROUTINE CD_LAMINAR_B(hst, hstb, hk, hkb, rth, rthb, cd, cdb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hst(4), hk(4), rth(4)
    REAL*8 :: hstb(4), hkb(4), rthb(4)
    REAL*8 :: cd(4)
    REAL*8 :: cdb(4)
    REAL*8 :: d(4)
    REAL*8 :: db(4)
    INTEGER :: i
    REAL*8 :: temp
    REAL*8 :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    INTEGER :: branch
    DO i=1,4
      IF (hk(i) .LT. 4.0) THEN
        d(i) = 0.001025*(4.0-hk(i))**5.5 + 0.1035
        CALL PUSHCONTROL1B(1)
      ELSE
        d(i) = (0.207-0.003*(hk(i)-4.0)**2/(1.0+0.02*(hk(i)-4.0)**2))/&
&         2.0
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    db = 0.0_8
    tempb0 = cdb/rth
    db = hst*tempb0
    hstb = hstb + d*tempb0
    rthb = rthb - d*hst*tempb0/rth
    DO i=4,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        temp = 0.02*((hk(i)-4.0)*(hk(i)-4.0)) + 1.0
        tempb = -(0.003*db(i)/(temp*2.0))
        db(i) = 0.0_8
        hkb(i) = hkb(i) + (2*hk(i)-2*4.0-2*(hk(i)-4.0)**3*0.02/temp)*&
&         tempb
      ELSE
        hkb(i) = hkb(i) - 5.5*(4.0-hk(i))**4.5*0.001025*db(i)
        db(i) = 0.0_8
      END IF
    END DO
  END SUBROUTINE CD_LAMINAR_B

  SUBROUTINE CD_LAMINAR(hst, hk, rth, cd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hst(4), hk(4), rth(4)
    REAL*8, INTENT(OUT) :: cd(4)
    REAL*8 :: d(4)
    INTEGER :: i
    DO i=1,4
      IF (hk(i) .LT. 4.0) THEN
        d(i) = 0.001025*(4.0-hk(i))**5.5 + 0.1035
      ELSE
        d(i) = (0.207-0.003*(hk(i)-4.0)**2/(1.0+0.02*(hk(i)-4.0)**2))/&
&         2.0
      END IF
    END DO
    cd = d*hst/rth
  END SUBROUTINE CD_LAMINAR

!  Differentiation of hstar_turbulent in reverse (adjoint) mode:
!   gradient     of useful results: hst hk
!   with respect to varying inputs: hk
  SUBROUTINE HSTAR_TURBULENT_B(hk, hkb, me, hst, hstb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), me(4)
    REAL*8 :: hkb(4)
    REAL*8 :: hst(4)
    REAL*8 :: hstb(4)
    REAL*8 :: hstme0(4)
    REAL*8 :: hstme0b(4)
    INTRINSIC EXP
    INTRINSIC ATAN
    INTRINSIC TANH
    INTRINSIC SQRT
    REAL*8, DIMENSION(4) :: temp
    REAL*8, DIMENSION(4) :: temp0
    hstme0b = 0.0_8
    hstme0b = hstb/(me**2*0.014+1.0)
    temp = 10.0**(-hk+7.0)
    temp0 = 10.0**(-(1.46*hk)+4.0)
    WHERE (TANH(2.14*temp0) .EQ. 0.0)
      hkb = hkb + (temp*LOG(10.0)/(1.23*(1.0+((temp-1.0)/1.23)**2)*8.55)&
&       -2*EXP((-2)*hk)*3.84)*hstme0b
    ELSEWHERE
      hkb = hkb + (temp*LOG(10.0)/(1.23*(1.0+((temp-1.0)/1.23)**2)*8.55)&
&       +1.46*temp0*LOG(10.0)*2.14*(1.0-TANH(2.14*temp0)**2)*0.146/(2.0*&
&       SQRT(TANH(2.14*temp0)))-2*EXP((-2)*hk)*3.84)*hstme0b
    ENDWHERE
  END SUBROUTINE HSTAR_TURBULENT_B

  SUBROUTINE HSTAR_TURBULENT(hk, me, hst)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), me(4)
    REAL*8, INTENT(OUT) :: hst(4)
    REAL*8 :: hstme0(4)
    INTRINSIC EXP
    INTRINSIC ATAN
    INTRINSIC TANH
    INTRINSIC SQRT
    hstme0 = 1.81 + 3.84*EXP(-(2*hk)) - ATAN((10.0**(7.0-hk)-1.0)/1.23)/&
&     8.55 - 0.146*SQRT(TANH(2.14*10.0**(4.0-1.46*hk)))
    hst = (hstme0+0.028*me**2)/(1.0+0.014*me**2)
  END SUBROUTINE HSTAR_TURBULENT

!  Differentiation of hprime_turbulent in reverse (adjoint) mode:
!   gradient     of useful results: hpr hk
!   with respect to varying inputs: hk
  SUBROUTINE HPRIME_TURBULENT_B(me, hk, hkb, hpr, hprb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: me(4), hk(4)
    REAL*8 :: hkb(4)
    REAL*8 :: hpr(4)
    REAL*8 :: hprb(4)
    hkb = hkb - 0.064*me**2*hprb/(hk-0.8)**2
  END SUBROUTINE HPRIME_TURBULENT_B

  SUBROUTINE HPRIME_TURBULENT(me, hk, hpr)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: me(4), hk(4)
    REAL*8, INTENT(OUT) :: hpr(4)
    hpr = me**2*(0.251+0.064/(hk-0.8))
  END SUBROUTINE HPRIME_TURBULENT

  SUBROUTINE FC(me, gamma, f)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: me(4), gamma
    REAL*8, INTENT(OUT) :: f(4)
    INTRINSIC SQRT
    f = SQRT(1.0 + (gamma-1.0)*me**2/2)
  END SUBROUTINE FC

!  Differentiation of cf_turbulent in reverse (adjoint) mode:
!   gradient     of useful results: hk rth cf
!   with respect to varying inputs: hk rth
  SUBROUTINE CF_TURBULENT_B(hk, hkb, rth, rthb, f, cf, cfb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), rth(4), f(4)
    REAL*8 :: hkb(4), rthb(4)
    REAL*8 :: cf(4)
    REAL*8 :: cfb(4)
    REAL*8 :: cf_bar(4)
    REAL*8 :: cf_barb(4)
    INTRINSIC LOG10
    INTRINSIC EXP
    INTRINSIC TANH
    REAL*8, DIMENSION(4) :: temp
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: temp0
    cf_barb = 0.0_8
    cf_barb = cfb/f
    temp0 = LOG10(rth)
    temp = temp0**(-(0.31*hk)-1.74)
    tempb = EXP(-(1.33*hk))*0.3*cf_barb
    WHERE (temp0 .LE. 0.0) 
      hkb = hkb - (1.33*EXP(-(1.33*hk))*temp*0.3+8.0*(1.0-TANH(4.0-8.0*(&
&       hk/7.0))**2)*0.00011/7.0)*cf_barb
    ELSEWHERE
      hkb = hkb - (1.33*EXP(-(1.33*hk))*temp*0.3+8.0*(1.0-TANH(4.0-8.0*(&
&       hk/7.0))**2)*0.00011/7.0)*cf_barb - 0.31*temp*LOG(temp0)*tempb
    END WHERE
    WHERE (.NOT.(temp0 .LE. 0.0 .AND. ((-1.74) - 0.31*hk .EQ. 0.0 .OR. (&
&       -1.74) - 0.31*hk .NE. INT((-1.74) - 0.31*hk)))) rthb = rthb + ((&
&       -1.74)-0.31*hk)*temp0**((-2.74)-0.31*hk)*tempb/(rth*LOG(10.0))
  END SUBROUTINE CF_TURBULENT_B

  SUBROUTINE CF_TURBULENT(hk, rth, f, cf)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), rth(4), f(4)
    REAL*8, INTENT(OUT) :: cf(4)
    REAL*8 :: cf_bar(4)
    INTRINSIC LOG10
    INTRINSIC EXP
    INTRINSIC TANH
    cf_bar = 0.3*LOG10(rth)**(-(0.31*hk)-1.74)*EXP(-(1.33*hk)) + 0.00011&
&     *(TANH(4.0-8.0*hk/7.0)-1.0)
    cf = cf_bar/f
  END SUBROUTINE CF_TURBULENT

!  Differentiation of cd_turbulent in reverse (adjoint) mode:
!   gradient     of useful results: cd
!   with respect to varying inputs: hk rth
  SUBROUTINE CD_TURBULENT_B(hk, hkb, f, me, rth, rthb, cd, cdb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), f(4), me(4), rth(4)
    REAL*8 :: hkb(4), rthb(4)
    REAL*8 :: cd(4)
    REAL*8 :: cdb(4)
    REAL*8 :: a(4), b(4), c(4)
    REAL*8 :: ab(4), bb(4)
    INTEGER :: i
    INTRINSIC EXP
    REAL*8, DIMENSION(4) :: tempb
    INTEGER :: branch
    DO i=1,4
      IF (hk(i) .LT. 3.5) THEN
        a(i) = 0.160*(hk(i)-3.5) - 0.550
        CALL PUSHCONTROL1B(1)
      ELSE
        a(i) = 0.438 - 0.280*hk(i)
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    c = f*(1.0+0.05*me**1.4)
    rthb = 0.0_8
    ab = 0.0_8
    bb = 0.0_8
    tempb = 2*cdb/c
    bb = tempb
    ab = rth**(-0.574)*tempb
    rthb = -(0.574*rth**(-1.574)*a*tempb)
    hkb = 0.0_8
    hkb = (2*hk*0.117*EXP(0.117*hk**2)*3e-5+2.1*hk**1.1*0.15*EXP(-(0.15*&
&     hk**2.1))*0.011)*bb
    DO i=4,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        hkb(i) = hkb(i) - 0.280*ab(i)
        ab(i) = 0.0_8
      ELSE
        hkb(i) = hkb(i) + 0.160*ab(i)
        ab(i) = 0.0_8
      END IF
    END DO
  END SUBROUTINE CD_TURBULENT_B

  SUBROUTINE CD_TURBULENT(hk, f, me, rth, cd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), f(4), me(4), rth(4)
    REAL*8, INTENT(OUT) :: cd(4)
    REAL*8 :: a(4), b(4), c(4)
    INTEGER :: i
    INTRINSIC EXP
    DO i=1,4
      IF (hk(i) .LT. 3.5) THEN
        a(i) = 0.160*(hk(i)-3.5) - 0.550
      ELSE
        a(i) = 0.438 - 0.280*hk(i)
      END IF
    END DO
    b = 0.009 - 0.011*EXP(-(0.15*hk**2.1)) + 3e-5*EXP(0.117*hk**2)
    c = f*(1.0+0.05*me**1.4)
    cd = 2*(b+a*rth**(-0.574))/c
  END SUBROUTINE CD_TURBULENT

!  Differentiation of sigma_n in reverse (adjoint) mode:
!   gradient     of useful results: nts sn
!   with respect to varying inputs: nts
  SUBROUTINE SIGMA_N_B(nts, ntsb, a, ncrit, sn, snb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: nts(4), a, ncrit
    REAL*8 :: ntsb(4)
    REAL*8 :: sn(4)
    REAL*8 :: snb(4)
    REAL*8, DIMENSION(4) :: arg1
    REAL*8, DIMENSION(4) :: arg1b
    arg1(:) = a*(nts-ncrit)
    CALL EXPIT_B(arg1(:), arg1b(:), 4, sn, snb)
    ntsb = ntsb + a*arg1b
  END SUBROUTINE SIGMA_N_B

  SUBROUTINE SIGMA_N(nts, a, ncrit, sn)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: nts(4), a, ncrit
    REAL*8, INTENT(OUT) :: sn(4)
    REAL*8, DIMENSION(4) :: arg1
    arg1(:) = a*(nts-ncrit)
    CALL EXPIT(arg1(:), 4, sn)
  END SUBROUTINE SIGMA_N

!  Differentiation of a_crossflow in reverse (adjoint) mode:
!   gradient     of useful results: cf beta a
!   with respect to varying inputs: cf beta
  SUBROUTINE A_CROSSFLOW_B(cf, cfb, beta, betab, me, a, ab)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: cf(4), beta(4), me(4)
    REAL*8 :: cfb(4), betab(4)
    REAL*8 :: a(4)
    REAL*8 :: ab(4)
    REAL*8 :: g(4)
    REAL*8 :: gb(4)
    INTRINSIC COS
    INTRINSIC SQRT
    INTRINSIC TAN
    REAL*8, DIMENSION(4) :: temp
    REAL*8, DIMENSION(4) :: tempb
    g = SQRT(cf*COS(beta)*(1.0+0.18*me**2))
    gb = 0.0_8
    tempb = TAN(beta)*ab/(g-1.0)
    gb = (1.0-g/(g-1.0))*tempb
    temp = COS(beta)
    WHERE ((me**2*0.18+1.0)*(cf*temp) .EQ. 0.0) 
      tempb = 0.0_8
    ELSEWHERE
      tempb = (me**2*0.18+1.0)*gb/(2.0*SQRT((me**2*0.18+1.0)*(cf*temp)))
    END WHERE
    betab = betab + (1.0+TAN(beta)**2)*(g/(g-1.0)+1.0)*ab - SIN(beta)*cf&
&     *tempb
    cfb = cfb + temp*tempb
  END SUBROUTINE A_CROSSFLOW_B

  SUBROUTINE A_CROSSFLOW(cf, beta, me, a)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: cf(4), beta(4), me(4)
    REAL*8, INTENT(OUT) :: a(4)
    REAL*8 :: g(4)
    INTRINSIC COS
    INTRINSIC SQRT
    INTRINSIC TAN
    g = SQRT(cf*COS(beta)*(1.0+0.18*me**2))
    a = TAN(beta)*(g/(g-1.0)+1.0)
  END SUBROUTINE A_CROSSFLOW

!  Differentiation of deltastar_innode in reverse (adjoint) mode:
!   gradient     of useful results: h th11 deltastar_1 deltastar_2
!                a
!   with respect to varying inputs: h th11 a
  SUBROUTINE DELTASTAR_INNODE_B(th11, th11b, h, hb, a, ab, deltastar_1, &
&   deltastar_1b, deltastar_2, deltastar_2b)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: th11(4), h(4), a(4)
    REAL*8 :: th11b(4), hb(4), ab(4)
    REAL*8 :: deltastar_1(4), deltastar_2(4)
    REAL*8 :: deltastar_1b(4), deltastar_2b(4)
    deltastar_1 = h*th11
    ab = ab - deltastar_1*deltastar_2b
    deltastar_1b = deltastar_1b - a*deltastar_2b
    hb = hb + th11*deltastar_1b
    th11b = th11b + h*deltastar_1b
  END SUBROUTINE DELTASTAR_INNODE_B

  SUBROUTINE DELTASTAR_INNODE(th11, h, a, deltastar_1, deltastar_2)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: th11(4), h(4), a(4)
    REAL*8, INTENT(OUT) :: deltastar_1(4), deltastar_2(4)
    deltastar_1 = h*th11
    deltastar_2 = -(a*deltastar_1)
  END SUBROUTINE DELTASTAR_INNODE

!  Differentiation of theta_innode in reverse (adjoint) mode:
!   gradient     of useful results: th22 th11 th12 deltastar_2
!                a th21
!   with respect to varying inputs: th11 deltastar_2 a
  SUBROUTINE THETA_INNODE_B(th11, th11b, a, ab, deltastar_2, &
&   deltastar_2b, th12, th12b, th21, th21b, th22, th22b)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: th11(4), a(4), deltastar_2(4)
    REAL*8 :: th11b(4), ab(4), deltastar_2b(4)
    REAL*8 :: th12(4), th21(4), th22(4)
    REAL*8 :: th12b(4), th21b(4), th22b(4)
    th21 = -(a*th11)
    th12 = th21 - deltastar_2
    th12b = th12b - a*th22b
    th21b = th21b + th12b
    ab = ab - th12*th22b - th11*th21b
    deltastar_2b = deltastar_2b - th12b
    th11b = th11b - a*th21b
  END SUBROUTINE THETA_INNODE_B

  SUBROUTINE THETA_INNODE(th11, a, deltastar_2, th12, th21, th22)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: th11(4), a(4), deltastar_2(4)
    REAL*8, INTENT(OUT) :: th12(4), th21(4), th22(4)
    th21 = -(a*th11)
    th12 = th21 - deltastar_2
    th22 = -(a*th12)
  END SUBROUTINE THETA_INNODE

!  Differentiation of thetastar_innode in reverse (adjoint) mode:
!   gradient     of useful results: th22 thst1 thst2 th11 deltastar_1
!   with respect to varying inputs: th22 hst th11 deltastar_1 a
  SUBROUTINE THETASTAR_INNODE_B(hst, hstb, a, ab, deltastar_1, &
&   deltastar_1b, th11, th11b, th22, th22b, thst1, thst1b, thst2, thst2b&
& )
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hst(4), a(4), deltastar_1(4), th11(4), th22(4)
    REAL*8 :: hstb(4), ab(4), deltastar_1b(4), th11b(4), th22b(4)
    REAL*8 :: thst1(4), thst2(4)
    REAL*8 :: thst1b(4), thst2b(4)
    REAL*8, DIMENSION(4) :: tempb
    thst1 = hst*th11
    ab = 0.0_8
    ab = (deltastar_1+th11+th22-thst1)*thst2b
    tempb = a*thst2b
    deltastar_1b = deltastar_1b + tempb
    th22b = th22b + tempb
    thst1b = thst1b - tempb
    th11b = th11b + tempb + hst*thst1b
    hstb = 0.0_8
    hstb = th11*thst1b
  END SUBROUTINE THETASTAR_INNODE_B

  SUBROUTINE THETASTAR_INNODE(hst, a, deltastar_1, th11, th22, thst1, &
&   thst2)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hst(4), a(4), deltastar_1(4), th11(4), th22(4)
    REAL*8, INTENT(OUT) :: thst1(4), thst2(4)
    thst1 = hst*th11
    thst2 = a*(deltastar_1+th11+th22-thst1)
  END SUBROUTINE THETASTAR_INNODE

!  Differentiation of deltaprime_innode in reverse (adjoint) mode:
!   gradient     of useful results: deltaprime_1 deltaprime_2 th11
!                a
!   with respect to varying inputs: hpr th11 a
  SUBROUTINE DELTAPRIME_INNODE_B(hpr, hprb, a, ab, th11, th11b, &
&   deltaprime_1, deltaprime_1b, deltaprime_2, deltaprime_2b)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hpr(4), a(4), th11(4)
    REAL*8 :: hprb(4), ab(4), th11b(4)
    REAL*8 :: deltaprime_1(4), deltaprime_2(4)
    REAL*8 :: deltaprime_1b(4), deltaprime_2b(4)
    deltaprime_1 = hpr*th11
    ab = ab - deltaprime_1*deltaprime_2b
    deltaprime_1b = deltaprime_1b - a*deltaprime_2b
    hprb = 0.0_8
    hprb = th11*deltaprime_1b
    th11b = th11b + hpr*deltaprime_1b
  END SUBROUTINE DELTAPRIME_INNODE_B

  SUBROUTINE DELTAPRIME_INNODE(hpr, a, th11, deltaprime_1, deltaprime_2)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hpr(4), a(4), th11(4)
    REAL*8, INTENT(OUT) :: deltaprime_1(4), deltaprime_2(4)
    deltaprime_1 = hpr*th11
    deltaprime_2 = -(a*deltaprime_1)
  END SUBROUTINE DELTAPRIME_INNODE

!  Differentiation of cd_innode in reverse (adjoint) mode:
!   gradient     of useful results: cd_2 cd a
!   with respect to varying inputs: cd a
  SUBROUTINE CD_INNODE_B(cd, cdb, a, ab, cd_2, cd_2b)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: cd(4), a(4)
    REAL*8 :: cdb(4), ab(4)
    REAL*8 :: cd_2(4)
    REAL*8 :: cd_2b(4)
    REAL*8 :: a_aux(4), base, lbase, eden, enum, expon
    REAL*8 :: baseb, edenb, enumb, exponb
    INTEGER :: i
    INTRINSIC ABS
    INTRINSIC LOG
    LOGICAL, DIMENSION(4) :: mask
    REAL*8 :: tempb
    INTEGER :: branch
    mask = a .GE. 0.0
    WHERE (mask) 
      a_aux = a
    ELSEWHERE
      a_aux = -a
    END WHERE
    DO i=1,4
      base = 14667.0*cd(i) + 3.0
      IF (a_aux(i) .GT. 1e-15) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    DO i=4,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        baseb = 0.0_8
      ELSE
        base = 14667.0*cd(i) + 3.0
        eden = 1020.0*cd(i) + 4.0
        enum = a(i) + 10.0
        expon = enum/eden
        tempb = SUM(cd_2b)
        IF (base .LE. 0.0 .AND. (expon .EQ. 0.0 .OR. expon .NE. INT(&
&           expon))) THEN
          baseb = 0.0_8
        ELSE
          baseb = expon*base**(expon-1)*tempb
        END IF
        IF (base .LE. 0.0) THEN
          exponb = 0.0_8
        ELSE
          exponb = base**expon*LOG(base)*tempb
        END IF
        enumb = exponb/eden
        edenb = -(enum*exponb/eden**2)
        ab(i) = ab(i) + enumb
        cdb(i) = cdb(i) + 1020.0*edenb
        cd_2b = 0.0_8
      END IF
      cdb(i) = cdb(i) + 14667.0*baseb
    END DO
  END SUBROUTINE CD_INNODE_B

  SUBROUTINE CD_INNODE(cd, a, cd_2)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: cd(4), a(4)
    REAL*8, INTENT(OUT) :: cd_2(4)
    REAL*8 :: a_aux(4), base, lbase, eden, enum, expon
    INTEGER :: i
    INTRINSIC ABS
    INTRINSIC LOG
    LOGICAL, DIMENSION(4) :: mask
    mask = a .GE. 0.0
    WHERE (mask) 
      a_aux = a
    ELSEWHERE
      a_aux = -a
    END WHERE
    DO i=1,4
      base = 14667.0*cd(i) + 3.0
      IF (a_aux(i) .GT. 1e-15) THEN
        lbase = LOG(base)
        eden = 1020.0*cd(i) + 4.0
        enum = a(i) + 10.0
        expon = enum/eden
        cd_2 = base**expon
      END IF
    END DO
  END SUBROUTINE CD_INNODE

!  Differentiation of j_innode in reverse (adjoint) mode:
!   gradient     of useful results: jxx jxz jzx th11 jzz
!   with respect to varying inputs: th22 th11 th12 th21
  SUBROUTINE J_INNODE_B(th11, th11b, th12, th12b, th21, th21b, th22, &
&   th22b, u, w, rho, jxx, jxxb, jxz, jxzb, jzx, jzxb, jzz, jzzb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: th11(4), th12(4), th21(4), th22(4), u(4), w(4)&
&   , rho(4)
    REAL*8 :: th11b(4), th12b(4), th21b(4), th22b(4)
    REAL*8 :: jxx(4), jxz(4), jzx(4), jzz(4)
    REAL*8 :: jxxb(4), jxzb(4), jzxb(4), jzzb(4)
    REAL*8 :: u2(4), uw(4), w2(4)
    REAL*8, DIMENSION(4) :: tempb
    u2 = u**2
    uw = u*w
    w2 = w**2
    th22b = 0.0_8
    th12b = 0.0_8
    th21b = 0.0_8
    tempb = rho*jzzb
    th11b = th11b + w2*tempb
    th12b = uw*tempb
    th21b = uw*tempb
    th22b = u2*tempb
    tempb = rho*jzxb
    th11b = th11b + uw*tempb
    th12b = th12b - w2*tempb
    th21b = th21b + u2*tempb
    th22b = th22b - uw*tempb
    tempb = rho*jxzb
    th11b = th11b + uw*tempb
    th12b = th12b + u2*tempb
    th21b = th21b - w2*tempb
    th22b = th22b - uw*tempb
    tempb = rho*jxxb
    th11b = th11b + u2*tempb
    th12b = th12b - uw*tempb
    th22b = th22b + w2*tempb
    th21b = th21b - uw*tempb
  END SUBROUTINE J_INNODE_B

  SUBROUTINE J_INNODE(th11, th12, th21, th22, u, w, rho, jxx, jxz, jzx, &
&   jzz)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: th11(4), th12(4), th21(4), th22(4), u(4), w(4)&
&   , rho(4)
    REAL*8, INTENT(OUT) :: jxx(4), jxz(4), jzx(4), jzz(4)
    REAL*8 :: u2(4), uw(4), w2(4)
    u2 = u**2
    uw = u*w
    w2 = w**2
    jxx = (u2*th11-uw*th12-uw*th21+w2*th22)*rho
    jxz = (uw*th11+u2*th12-w2*th21-uw*th22)*rho
    jzx = (uw*th11-w2*th12+u2*th21-uw*th22)*rho
    jzz = (w2*th11+uw*th12+uw*th21+u2*th22)*rho
  END SUBROUTINE J_INNODE

!  Differentiation of m_innode in reverse (adjoint) mode:
!   gradient     of useful results: mz mx
!   with respect to varying inputs: deltastar_1 deltastar_2
  SUBROUTINE M_INNODE_B(deltastar_1, deltastar_1b, deltastar_2, &
&   deltastar_2b, u, w, rho, mx, mxb, mz, mzb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: deltastar_1(4), deltastar_2(4), u(4), w(4), &
&   rho(4)
    REAL*8 :: deltastar_1b(4), deltastar_2b(4)
    REAL*8 :: mx(4), mz(4)
    REAL*8 :: mxb(4), mzb(4)
    deltastar_1b = 0.0_8
    deltastar_2b = 0.0_8
    deltastar_2b = u*rho*mzb + w*rho*mxb
    deltastar_1b = u*rho*mxb - w*rho*mzb
  END SUBROUTINE M_INNODE_B

  SUBROUTINE M_INNODE(deltastar_1, deltastar_2, u, w, rho, mx, mz)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: deltastar_1(4), deltastar_2(4), u(4), w(4), &
&   rho(4)
    REAL*8, INTENT(OUT) :: mx(4), mz(4)
    mx = (deltastar_1*u+deltastar_2*w)*rho
    mz = (deltastar_2*u-deltastar_1*w)*rho
  END SUBROUTINE M_INNODE

!  Differentiation of e_innode in reverse (adjoint) mode:
!   gradient     of useful results: ex ez
!   with respect to varying inputs: thst1 thst2
  SUBROUTINE E_INNODE_B(thst1, thst1b, thst2, thst2b, u, w, q, rho, ex, &
&   exb, ez, ezb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: thst1(4), thst2(4), u(4), w(4), q(4), rho(4)
    REAL*8 :: thst1b(4), thst2b(4)
    REAL*8 :: ex(4), ez(4)
    REAL*8 :: exb(4), ezb(4)
    REAL*8, DIMENSION(4) :: tempb
    thst1b = 0.0_8
    thst2b = 0.0_8
    tempb = rho*q**2*ezb
    thst2b = u*tempb
    thst1b = -(w*tempb)
    tempb = rho*q**2*exb
    thst1b = thst1b + u*tempb
    thst2b = thst2b + w*tempb
  END SUBROUTINE E_INNODE_B

  SUBROUTINE E_INNODE(thst1, thst2, u, w, q, rho, ex, ez)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: thst1(4), thst2(4), u(4), w(4), q(4), rho(4)
    REAL*8, INTENT(OUT) :: ex(4), ez(4)
    ex = rho*q**2*(thst1*u+thst2*w)
    ez = rho*q**2*(thst2*u-thst1*w)
  END SUBROUTINE E_INNODE

!  Differentiation of rhoq_innode in reverse (adjoint) mode:
!   gradient     of useful results: rhoqx rhoqz
!   with respect to varying inputs: deltaprime_1 deltaprime_2
  SUBROUTINE RHOQ_INNODE_B(deltaprime_1, deltaprime_1b, deltaprime_2, &
&   deltaprime_2b, u, w, rho, rhoqx, rhoqxb, rhoqz, rhoqzb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: deltaprime_1(4), deltaprime_2(4), u(4), w(4), &
&   rho(4)
    REAL*8 :: deltaprime_1b(4), deltaprime_2b(4)
    REAL*8 :: rhoqx(4), rhoqz(4)
    REAL*8 :: rhoqxb(4), rhoqzb(4)
    deltaprime_1b = 0.0_8
    deltaprime_2b = 0.0_8
    deltaprime_2b = u*rho*rhoqzb + w*rho*rhoqxb
    deltaprime_1b = u*rho*rhoqxb - w*rho*rhoqzb
  END SUBROUTINE RHOQ_INNODE_B

  SUBROUTINE RHOQ_INNODE(deltaprime_1, deltaprime_2, u, w, rho, rhoqx, &
&   rhoqz)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: deltaprime_1(4), deltaprime_2(4), u(4), w(4), &
&   rho(4)
    REAL*8, INTENT(OUT) :: rhoqx(4), rhoqz(4)
    rhoqx = rho*(deltaprime_1*u+deltaprime_2*w)
    rhoqz = rho*(deltaprime_2*u-deltaprime_1*w)
  END SUBROUTINE RHOQ_INNODE

!  Differentiation of tau_innode in reverse (adjoint) mode:
!   gradient     of useful results: taux tauz
!   with respect to varying inputs: cf_1 cf_2
  SUBROUTINE TAU_INNODE_B(cf_1, cf_1b, cf_2, cf_2b, u, w, q, rho, taux, &
&   tauxb, tauz, tauzb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: cf_1(4), cf_2(4), u(4), w(4), q(4), rho(4)
    REAL*8 :: cf_1b(4), cf_2b(4)
    REAL*8 :: taux(4), tauz(4)
    REAL*8 :: tauxb(4), tauzb(4)
    REAL*8, DIMENSION(4) :: tempb
    cf_2b = 0.0_8
    tempb = rho*tauzb/2
    cf_2b = (q*u-q*w)*tempb
    cf_1b = 0.0_8
    tempb = rho*tauxb/2
    cf_1b = q*u*tempb
    cf_2b = cf_2b + q*w*tempb
  END SUBROUTINE TAU_INNODE_B

  SUBROUTINE TAU_INNODE(cf_1, cf_2, u, w, q, rho, taux, tauz)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: cf_1(4), cf_2(4), u(4), w(4), q(4), rho(4)
    REAL*8, INTENT(OUT) :: taux(4), tauz(4)
    taux = rho*(cf_1*q*u+cf_2*q*w)/2
    tauz = rho*(cf_2*q*u-cf_2*q*w)/2
  END SUBROUTINE TAU_INNODE

!  Differentiation of matbyvec in reverse (adjoint) mode:
!   gradient     of useful results: x y
!   with respect to varying inputs: x y
  SUBROUTINE MATBYVEC_B(a, x, xb, y, yb)
    IMPLICIT NONE
! custom subroutine for matrix by vector multiplication to improve performance of Tapenade differentiated
! code
    REAL*8, INTENT(IN) :: a(4, 4), x(4)
    REAL*8 :: xb(4)
    REAL*8, INTENT(INOUT) :: y(4)
    REAL*8, INTENT(INOUT) :: yb(4)
    INTEGER :: i, j
    DO i=4,1,-1
      DO j=4,1,-1
        xb(j) = xb(j) + a(i, j)*yb(i)
      END DO
    END DO
  END SUBROUTINE MATBYVEC_B

  SUBROUTINE MATBYVEC(a, x, y)
    IMPLICIT NONE
! custom subroutine for matrix by vector multiplication to improve performance of Tapenade differentiated
! code
    REAL*8, INTENT(IN) :: a(4, 4), x(4)
    REAL*8, INTENT(INOUT) :: y(4)
    INTEGER :: i, j
    DO i=1,4
      DO j=1,4
        y(i) = y(i) + a(i, j)*x(j)
      END DO
    END DO
  END SUBROUTINE MATBYVEC

!  Differentiation of mat3byvec in reverse (adjoint) mode:
!   gradient     of useful results: x y z
!   with respect to varying inputs: x y z
  SUBROUTINE MAT3BYVEC_B(a, x, xb, y, yb, z, zb)
    IMPLICIT NONE
! custom subroutine for rank 3 matrix by vectors multiplication to improve performance of Tapenade differentiated
! code
    REAL*8, INTENT(IN) :: a(4, 4, 4), x(4), y(4)
    REAL*8 :: xb(4), yb(4)
    REAL*8, INTENT(INOUT) :: z(4)
    REAL*8, INTENT(INOUT) :: zb(4)
    REAL*8 :: interm(4)
    REAL*8 :: intermb(4)
    INTEGER :: i, j
    DO i=1,4
      CALL PUSHREAL8ARRAY(interm, 4)
      interm = 0.0
      CALL MATBYVEC(a(i, :, :), y, interm)
    END DO
    DO i=4,1,-1
      intermb = 0.0_8
      intermb(1) = intermb(1) + x(1)*zb(i)
      xb(1) = xb(1) + interm(1)*zb(i)
      intermb(2) = intermb(2) + x(2)*zb(i)
      xb(2) = xb(2) + interm(2)*zb(i)
      intermb(3) = intermb(3) + x(3)*zb(i)
      xb(3) = xb(3) + interm(3)*zb(i)
      intermb(4) = intermb(4) + x(4)*zb(i)
      xb(4) = xb(4) + interm(4)*zb(i)
      CALL MATBYVEC_B(a(i, :, :), y, yb, interm, intermb)
      CALL POPREAL8ARRAY(interm, 4)
    END DO
  END SUBROUTINE MAT3BYVEC_B

  SUBROUTINE MAT3BYVEC(a, x, y, z)
    IMPLICIT NONE
! custom subroutine for rank 3 matrix by vectors multiplication to improve performance of Tapenade differentiated
! code
    REAL*8, INTENT(IN) :: a(4, 4, 4), x(4), y(4)
    REAL*8, INTENT(INOUT) :: z(4)
    REAL*8 :: interm(4)
    INTEGER :: i, j
    DO i=1,4
      interm = 0.0
      CALL MATBYVEC(a(i, :, :), y, interm)
      z(i) = z(i) + interm(1)*x(1) + interm(2)*x(2) + interm(3)*x(3) + &
&       interm(4)*x(4)
    END DO
  END SUBROUTINE MAT3BYVEC

!  Differentiation of cell_getresiduals in reverse (adjoint) mode:
!   gradient     of useful results: h rmass n nts rts th11 beta
!                rmomx rmomz ren
!   with respect to varying inputs: h n nts th11 beta
  SUBROUTINE CELL_GETRESIDUALS_B(n, nb, th11, th11b, h, hb, beta, betab&
&   , nts, ntsb, qx, qy, qz, rho0, v_sonic, a_transition, a_rethcrit, &
&   mtosys, uinf, mu, ncrit, gamma, rvj, rdxj, rdyj, rudxj, rudyj, rmass&
&   , rmassb, rmomx, rmomxb, rmomz, rmomzb, ren, renb, rts, rtsb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: n(4), th11(4), h(4), beta(4), nts(4), qx(4), &
&   qy(4), qz(4)
    REAL*8 :: nb(4), th11b(4), hb(4), betab(4), ntsb(4)
    REAL*8, INTENT(IN) :: rho0, v_sonic, a_transition, a_rethcrit, &
&   mtosys(3, 3), uinf, mu, ncrit, gamma, rvj(4, 4), rdxj(4, 4), rdyj(4&
&   , 4), rudxj(4, 4, 4), rudyj(4, 4, 4)
    REAL*8 :: rmass(4), rmomx(4), rmomz(4), ren(4), rts(4)
    REAL*8 :: rmassb(4), rmomxb(4), rmomzb(4), renb(4), rtsb(4)
! residual matrixes: rows for residual number
    REAL*8 :: qe(4), u(4), w(4), m(4), rho(4), rth(4), hk(4), p(4), sgn(&
&   4), cl(4), ct(4), cf(4), f(4), a_cr(4), cf_cr(4), hst(4), hpr(4), cd&
&   (4), cd_cr(4), taux(4), tauz(4), d(4), dst1(4), dst2(4), th12(4), &
&   th21(4), th22(4), dpr1(4), dpr2(4), thst1(4), thst2(4), jxx(4), jxz(&
&   4), jzx(4), jzz(4), mx(4), mz(4), ex(4), ez(4), rhoqx(4), rhoqz(4)
    REAL*8 :: ub(4), wb(4), rthb(4), hkb(4), pb(4), sgnb(4), clb(4), ctb&
&   (4), cfb(4), a_crb(4), cf_crb(4), hstb(4), hprb(4), cdb(4), cd_crb(4&
&   ), tauxb(4), tauzb(4), db(4), dst1b(4), dst2b(4), th12b(4), th21b(4)&
&   , th22b(4), dpr1b(4), dpr2b(4), thst1b(4), thst2b(4), jxxb(4), jxzb(&
&   4), jzxb(4), jzzb(4), mxb(4), mzb(4), exb(4), ezb(4), rhoqxb(4), &
&   rhoqzb(4)
    INTRINSIC TAN
    REAL*8, DIMENSION(4) :: arg1
    REAL*8, DIMENSION(4) :: arg1b
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: arg10
    REAL*8, DIMENSION(4) :: arg1b0
    REAL*8, DIMENSION(4) :: arg11
    REAL*8, DIMENSION(4) :: arg1b1
    CALL UWQ(qx, qy, qz, mtosys, u, w, qe)
    CALL MACHE(qe, v_sonic, m)
    CALL RHOE(m, v_sonic, rho0, uinf, rho)
    CALL RETH(qe, rho, th11, mu, rth)
    CALL HK_CLOSURE(h, m, hk)
    CALL SIGMA_N(nts, ncrit, a_transition, sgn)
    CALL FC(m, gamma, f)
! closure relationships
    CALL CF_LAMINAR(hk, rth, cl)
    CALL CF_TURBULENT(hk, rth, f, ct)
    cf = sgn*ct + (1.0-sgn)*cl
    CALL A_CROSSFLOW(cf, beta, m, a_cr)
    CALL PUSHREAL8ARRAY(cl, 4)
    CALL HSTAR_LAMINAR(hk, cl)
    CALL PUSHREAL8ARRAY(ct, 4)
    CALL HSTAR_TURBULENT(hk, m, ct)
    hst = sgn*ct + (1.0-sgn)*cl
    CALL PUSHREAL8ARRAY(cl, 4)
    CALL HPRIME_LAMINAR(m, hk, cl)
    CALL PUSHREAL8ARRAY(ct, 4)
    CALL HPRIME_TURBULENT(m, hk, ct)
    hpr = sgn*ct + (1.0-sgn)*cl
    CALL PUSHREAL8ARRAY(cl, 4)
    CALL CD_LAMINAR(hst, hk, rth, cl)
    CALL PUSHREAL8ARRAY(ct, 4)
    CALL CD_TURBULENT(hk, f, m, rth, ct)
    cd = sgn*ct + (1.0-sgn)*cl
    CALL DELTASTAR_INNODE(th11, h, a_cr, dst1, dst2)
    CALL THETA_INNODE(th11, a_cr, dst2, th12, th21, th22)
    CALL DELTAPRIME_INNODE(hpr, a_cr, th11, dpr1, dpr2)
    CALL M_INNODE(dst1, dst2, u, w, rho, mx, mz)
    CALL RHOQ_INNODE(dpr1, dpr2, u, w, rho, rhoqx, rhoqz)
! initialize residuals
    arg1(:) = qe**2
    arg1b = 0.0_8
    CALL MATBYVEC_B(rvj, arg1(:), arg1b(:), rmass, rmassb)
    nb = nb - rho*arg1b
    mzb = 0.0_8
    CALL MATBYVEC_B(rdyj, mz, mzb, rmass, rmassb)
    mxb = 0.0_8
    CALL MATBYVEC_B(rdxj, mx, mxb, rmass, rmassb)
    arg1b = 0.0_8
    CALL MATBYVEC_B(rvj, arg1(:), arg1b(:), rts, rtsb)
    pb = 0.0_8
    pb = -(qe*arg1b(:))
    wb = 0.0_8
    CALL MAT3BYVEC_B(rudyj, w, wb, nts, ntsb, rts, rtsb)
    ub = 0.0_8
    CALL MAT3BYVEC_B(rudxj, u, ub, nts, ntsb, rts, rtsb)
    rhoqzb = 0.0_8
    arg1b = 0.0_8
    CALL MAT3BYVEC_B(rudyj, rhoqz, rhoqzb, arg1(:), arg1b(:), ren, renb)
    arg1(:) = qe**2
    rhoqxb = 0.0_8
    arg1b = 0.0_8
    CALL MAT3BYVEC_B(rudxj, rhoqx, rhoqxb, arg1(:), arg1b(:), ren, renb)
    arg1b = 0.0_8
    CALL MATBYVEC_B(rvj, arg1(:), arg1b(:), ren, renb)
    db = 0.0_8
    db = -(2*arg1b(:))
    ezb = 0.0_8
    CALL MATBYVEC_B(rdyj, ez, ezb, ren, renb)
    exb = 0.0_8
    CALL MATBYVEC_B(rdxj, ex, exb, ren, renb)
    wb = 0.0_8
    CALL MAT3BYVEC_B(rudyj, mz, mzb, w, wb, rmomz, rmomzb)
    wb = 0.0_8
    CALL MAT3BYVEC_B(rudxj, mx, mxb, w, wb, rmomz, rmomzb)
    arg1b1 = 0.0_8
    CALL MATBYVEC_B(rvj, arg11, arg1b1, rmomz, rmomzb)
    tauzb = 0.0_8
    tauzb = -arg1b1
    jzzb = 0.0_8
    CALL MATBYVEC_B(rdyj, jzz, jzzb, rmomz, rmomzb)
    jzxb = 0.0_8
    CALL MATBYVEC_B(rdxj, jzx, jzxb, rmomz, rmomzb)
    ub = 0.0_8
    CALL MAT3BYVEC_B(rudyj, mz, mzb, u, ub, rmomx, rmomxb)
    ub = 0.0_8
    CALL MAT3BYVEC_B(rudxj, mx, mxb, u, ub, rmomx, rmomxb)
    arg1b0 = 0.0_8
    CALL MATBYVEC_B(rvj, arg10, arg1b0, rmomx, rmomxb)
    tauxb = 0.0_8
    tauxb = -arg1b0
    jxzb = 0.0_8
    CALL MATBYVEC_B(rdyj, jxz, jxzb, rmomx, rmomxb)
    jxxb = 0.0_8
    CALL MATBYVEC_B(rdxj, jxx, jxxb, rmomx, rmomxb)
    CALL RHOQ_INNODE_B(dpr1, dpr1b, dpr2, dpr2b, u, w, rho, rhoqx, &
&                rhoqxb, rhoqz, rhoqzb)
    CALL E_INNODE_B(thst1, thst1b, thst2, thst2b, u, w, qe, rho, ex, exb&
&             , ez, ezb)
    CALL M_INNODE_B(dst1, dst1b, dst2, dst2b, u, w, rho, mx, mxb, mz, &
&             mzb)
    CALL J_INNODE_B(th11, th11b, th12, th12b, th21, th21b, th22, th22b, &
&             u, w, rho, jxx, jxxb, jxz, jxzb, jzx, jzxb, jzz, jzzb)
    CALL THETASTAR_INNODE_B(hst, hstb, a_cr, a_crb, dst1, dst1b, th11, &
&                     th11b, th22, th22b, thst1, thst1b, thst2, thst2b)
    CALL DELTAPRIME_INNODE_B(hpr, hprb, a_cr, a_crb, th11, th11b, dpr1, &
&                      dpr1b, dpr2, dpr2b)
    CALL THETA_INNODE_B(th11, th11b, a_cr, a_crb, dst2, dst2b, th12, &
&                 th12b, th21, th21b, th22, th22b)
    CALL DELTASTAR_INNODE_B(th11, th11b, h, hb, a_cr, a_crb, dst1, dst1b&
&                     , dst2, dst2b)
    CALL TAU_INNODE_B(cf, cfb, cf_cr, cf_crb, u, w, qe, rho, taux, tauxb&
&               , tauz, tauzb)
    cd_crb = 0.0_8
    cdb = 0.0_8
    tempb = rho*qe**3*db
    cdb = tempb
    cd_crb = tempb
    CALL CD_INNODE_B(cd, cdb, a_cr, a_crb, cd_cr, cd_crb)
    sgnb = 0.0_8
    clb = 0.0_8
    ctb = 0.0_8
    sgnb = (ct-cl)*cdb
    ctb = sgn*cdb
    clb = (1.0-sgn)*cdb
    CALL POPREAL8ARRAY(ct, 4)
    CALL CD_TURBULENT_B(hk, hkb, f, m, rth, rthb, ct, ctb)
    CALL POPREAL8ARRAY(cl, 4)
    CALL CD_LAMINAR_B(hst, hstb, hk, hkb, rth, rthb, cl, clb)
    clb = 0.0_8
    ctb = 0.0_8
    sgnb = sgnb + (ct-cl)*hprb
    ctb = sgn*hprb
    clb = (1.0-sgn)*hprb
    CALL POPREAL8ARRAY(ct, 4)
    CALL HPRIME_TURBULENT_B(m, hk, hkb, ct, ctb)
    CALL POPREAL8ARRAY(cl, 4)
    CALL HPRIME_LAMINAR_B(m, hk, hkb, cl, clb)
    clb = 0.0_8
    ctb = 0.0_8
    sgnb = sgnb + (ct-cl)*hstb
    ctb = sgn*hstb
    clb = (1.0-sgn)*hstb
    CALL POPREAL8ARRAY(ct, 4)
    CALL HSTAR_TURBULENT_B(hk, hkb, m, ct, ctb)
    CALL POPREAL8ARRAY(cl, 4)
    CALL HSTAR_LAMINAR_B(hk, hkb, cl, clb)
    cfb = cfb - TAN(beta)*cf_crb
    betab = betab - (1.0+TAN(beta)**2)*cf*cf_crb
    CALL A_CROSSFLOW_B(cf, cfb, beta, betab, m, a_cr, a_crb)
    ctb = 0.0_8
    sgnb = sgnb + (ct-cl)*cfb
    ctb = sgn*cfb
    clb = clb + (1.0-sgn)*cfb
    CALL CF_TURBULENT_B(hk, hkb, rth, rthb, f, ct, ctb)
    CALL CF_LAMINAR_B(hk, hkb, rth, rthb, cl, clb)
    CALL SIGMA_N_B(nts, ntsb, ncrit, a_transition, sgn, sgnb)
    CALL P_TRANS_B(rth, rthb, hk, hkb, th11, th11b, a_rethcrit, p, pb)
    CALL HK_CLOSURE_B(h, hb, m, hk, hkb)
    CALL RETH_B(qe, rho, th11, th11b, mu, rth, rthb)
  END SUBROUTINE CELL_GETRESIDUALS_B

  SUBROUTINE CELL_GETRESIDUALS(n, th11, h, beta, nts, qx, qy, qz, rho0, &
&   v_sonic, a_transition, a_rethcrit, mtosys, uinf, mu, ncrit, gamma, &
&   rvj, rdxj, rdyj, rudxj, rudyj, rmass, rmomx, rmomz, ren, rts)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: n(4), th11(4), h(4), beta(4), nts(4), qx(4), &
&   qy(4), qz(4)
    REAL*8, INTENT(IN) :: rho0, v_sonic, a_transition, a_rethcrit, &
&   mtosys(3, 3), uinf, mu, ncrit, gamma, rvj(4, 4), rdxj(4, 4), rdyj(4&
&   , 4), rudxj(4, 4, 4), rudyj(4, 4, 4)
    REAL*8, INTENT(OUT) :: rmass(4), rmomx(4), rmomz(4), ren(4), rts(4)
! residual matrixes: rows for residual number
    REAL*8 :: qe(4), u(4), w(4), m(4), rho(4), rth(4), hk(4), p(4), sgn(&
&   4), cl(4), ct(4), cf(4), f(4), a_cr(4), cf_cr(4), hst(4), hpr(4), cd&
&   (4), cd_cr(4), taux(4), tauz(4), d(4), dst1(4), dst2(4), th12(4), &
&   th21(4), th22(4), dpr1(4), dpr2(4), thst1(4), thst2(4), jxx(4), jxz(&
&   4), jzx(4), jzz(4), mx(4), mz(4), ex(4), ez(4), rhoqx(4), rhoqz(4)
    INTRINSIC TAN
    REAL*8, DIMENSION(4) :: arg1
    CALL UWQ(qx, qy, qz, mtosys, u, w, qe)
    CALL MACHE(qe, v_sonic, m)
    CALL RHOE(m, v_sonic, rho0, uinf, rho)
    CALL RETH(qe, rho, th11, mu, rth)
    CALL HK_CLOSURE(h, m, hk)
    CALL P_TRANS(rth, hk, th11, a_rethcrit, p)
    CALL SIGMA_N(nts, ncrit, a_transition, sgn)
    CALL FC(m, gamma, f)
! closure relationships
    CALL CF_LAMINAR(hk, rth, cl)
    CALL CF_TURBULENT(hk, rth, f, ct)
    cf = sgn*ct + (1.0-sgn)*cl
    CALL A_CROSSFLOW(cf, beta, m, a_cr)
    cf_cr = -(cf*TAN(beta))
    CALL HSTAR_LAMINAR(hk, cl)
    CALL HSTAR_TURBULENT(hk, m, ct)
    hst = sgn*ct + (1.0-sgn)*cl
    CALL HPRIME_LAMINAR(m, hk, cl)
    CALL HPRIME_TURBULENT(m, hk, ct)
    hpr = sgn*ct + (1.0-sgn)*cl
    CALL CD_LAMINAR(hst, hk, rth, cl)
    CALL CD_TURBULENT(hk, f, m, rth, ct)
    cd = sgn*ct + (1.0-sgn)*cl
    CALL CD_INNODE(cd, a_cr, cd_cr)
    d = rho*qe**3*(cd+cd_cr)
    CALL TAU_INNODE(cf, cf_cr, u, w, qe, rho, taux, tauz)
    CALL DELTASTAR_INNODE(th11, h, a_cr, dst1, dst2)
    CALL THETA_INNODE(th11, a_cr, dst2, th12, th21, th22)
    CALL DELTAPRIME_INNODE(hpr, a_cr, th11, dpr1, dpr2)
    CALL THETASTAR_INNODE(hst, a_cr, dst1, th11, th22, thst1, thst2)
    CALL J_INNODE(th11, th12, th21, th22, u, w, rho, jxx, jxz, jzx, jzz)
    CALL M_INNODE(dst1, dst2, u, w, rho, mx, mz)
    CALL E_INNODE(thst1, thst2, u, w, qe, rho, ex, ez)
    CALL RHOQ_INNODE(dpr1, dpr2, u, w, rho, rhoqx, rhoqz)
! initialize residuals
    rmass = 0.0
    rmomx = 0.0
    rmomz = 0.0
    rts = 0.0
    ren = 0.0
    CALL MATBYVEC(rdxj, jxx, rmomx)
    CALL MATBYVEC(rdyj, jxz, rmomx)
    CALL MATBYVEC(rvj, -taux, rmomx)
    CALL MAT3BYVEC(rudxj, mx, u, rmomx)
    CALL MAT3BYVEC(rudyj, mz, u, rmomx)
    CALL MATBYVEC(rdxj, jzx, rmomz)
    CALL MATBYVEC(rdyj, jzz, rmomz)
    CALL MATBYVEC(rvj, -tauz, rmomz)
    CALL MAT3BYVEC(rudxj, mx, w, rmomz)
    CALL MAT3BYVEC(rudyj, mz, w, rmomz)
    CALL MATBYVEC(rdxj, ex, ren)
    CALL MATBYVEC(rdyj, ez, ren)
    arg1(:) = -(2*d)
    CALL MATBYVEC(rvj, arg1(:), ren)
    arg1(:) = qe**2
    CALL MAT3BYVEC(rudxj, rhoqx, arg1(:), ren)
    arg1(:) = qe**2
    CALL MAT3BYVEC(rudyj, rhoqz, arg1(:), ren)
    CALL MAT3BYVEC(rudxj, u, nts, rts)
    CALL MAT3BYVEC(rudyj, w, nts, rts)
    arg1(:) = -(qe*p)
    CALL MATBYVEC(rvj, arg1(:), rts)
    CALL MATBYVEC(rdxj, mx, rmass)
    CALL MATBYVEC(rdyj, mz, rmass)
    arg1(:) = -(rho*n)
    CALL MATBYVEC(rvj, arg1(:), rmass)
  END SUBROUTINE CELL_GETRESIDUALS

!  Differentiation of mesh_getresiduals in reverse (adjoint) mode:
!   gradient     of useful results: rmass rts rmomx rmomz ren
!   with respect to varying inputs: h rmass n nts rts th11 beta
!                rmomx rmomz ren
!   RW status of diff variables: h:out rmass:in-zero n:out nts:out
!                rts:in-zero th11:out beta:out rmomx:in-zero rmomz:in-zero
!                ren:in-zero
  SUBROUTINE MESH_GETRESIDUALS_B(nnodes, ncells, cellmat, n, nb, th11, &
&   th11b, h, hb, beta, betab, nts, ntsb, qx, qy, qz, rho0, v_sonic, &
&   a_transition, a_rethcrit, mtosys, uinf, mu, ncrit, gamma, rvj, rdxj&
&   , rdyj, rudxj, rudyj, rmass, rmassb, rmomx, rmomxb, rmomz, rmomzb, &
&   ren, renb, rts, rtsb)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nnodes, ncells
    INTEGER, INTENT(IN) :: cellmat(ncells, 4)
    REAL*8, INTENT(IN) :: n(nnodes), th11(nnodes), h(nnodes), beta(&
&   nnodes), nts(nnodes), qx(nnodes), qy(nnodes), qz(nnodes), rho0, &
&   v_sonic, a_transition, a_rethcrit, mtosys(ncells, 3, 3), uinf, mu, &
&   ncrit, gamma, rvj(ncells, 4, 4), rdxj(ncells, 4, 4), rdyj(ncells, 4&
&   , 4), rudxj(ncells, 4, 4, 4), rudyj(ncells, 4, 4, 4)
    REAL*8 :: nb(nnodes), th11b(nnodes), hb(nnodes), betab(nnodes), ntsb&
&   (nnodes)
    REAL*8 :: rmass(nnodes), rmomx(nnodes), rmomz(nnodes), ren(nnodes), &
&   rts(nnodes)
    REAL*8 :: rmassb(nnodes), rmomxb(nnodes), rmomzb(nnodes), renb(&
&   nnodes), rtsb(nnodes)
    INTEGER :: i, inds(4)
    REAL*8 :: rmass_l(4), rmomx_l(4), rmomz_l(4), ren_l(4), rts_l(4)
    REAL*8 :: rmass_lb(4), rmomx_lb(4), rmomz_lb(4), ren_lb(4), rts_lb(4&
&   )
    hb = 0.0_8
    nb = 0.0_8
    ntsb = 0.0_8
    th11b = 0.0_8
    betab = 0.0_8
    DO i=ncells,1,-1
      inds = cellmat(i, :)
      rts_lb = 0.0_8
      rts_lb = rtsb(inds)
      ren_lb = 0.0_8
      ren_lb = renb(inds)
      rmomz_lb = 0.0_8
      rmomz_lb = rmomzb(inds)
      rmomx_lb = 0.0_8
      rmomx_lb = rmomxb(inds)
      rmass_lb = 0.0_8
      rmass_lb = rmassb(inds)
      CALL CELL_GETRESIDUALS_B(n(inds), nb(inds), th11(inds), th11b(inds&
&                        ), h(inds), hb(inds), beta(inds), betab(inds), &
&                        nts(inds), ntsb(inds), qx(inds), qy(inds), qz(&
&                        inds), rho0, v_sonic, a_transition, a_rethcrit&
&                        , mtosys(i, :, :), uinf, mu, ncrit, gamma, rvj(&
&                        i, :, :), rdxj(i, :, :), rdyj(i, :, :), rudxj(i&
&                        , :, :, :), rudyj(i, :, :, :), rmass_l, &
&                        rmass_lb, rmomx_l, rmomx_lb, rmomz_l, rmomz_lb&
&                        , ren_l, ren_lb, rts_l, rts_lb)
    END DO
    rmassb = 0.0_8
    rtsb = 0.0_8
    rmomxb = 0.0_8
    rmomzb = 0.0_8
    renb = 0.0_8
  END SUBROUTINE MESH_GETRESIDUALS_B

  SUBROUTINE MESH_GETRESIDUALS(nnodes, ncells, cellmat, n, th11, h, beta&
&   , nts, qx, qy, qz, rho0, v_sonic, a_transition, a_rethcrit, mtosys, &
&   uinf, mu, ncrit, gamma, rvj, rdxj, rdyj, rudxj, rudyj, rmass, rmomx&
&   , rmomz, ren, rts)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nnodes, ncells
    INTEGER, INTENT(IN) :: cellmat(ncells, 4)
    REAL*8, INTENT(IN) :: n(nnodes), th11(nnodes), h(nnodes), beta(&
&   nnodes), nts(nnodes), qx(nnodes), qy(nnodes), qz(nnodes), rho0, &
&   v_sonic, a_transition, a_rethcrit, mtosys(ncells, 3, 3), uinf, mu, &
&   ncrit, gamma, rvj(ncells, 4, 4), rdxj(ncells, 4, 4), rdyj(ncells, 4&
&   , 4), rudxj(ncells, 4, 4, 4), rudyj(ncells, 4, 4, 4)
    REAL*8, INTENT(OUT) :: rmass(nnodes), rmomx(nnodes), rmomz(nnodes), &
&   ren(nnodes), rts(nnodes)
    INTEGER :: i, inds(4)
    REAL*8 :: rmass_l(4), rmomx_l(4), rmomz_l(4), ren_l(4), rts_l(4)
    rmass = 0.0
    rmomx = 0.0
    rmomz = 0.0
    ren = 0.0
    rts = 0.0
    DO i=1,ncells
      inds = cellmat(i, :)
      CALL CELL_GETRESIDUALS(n(inds), th11(inds), h(inds), beta(inds), &
&                      nts(inds), qx(inds), qy(inds), qz(inds), rho0, &
&                      v_sonic, a_transition, a_rethcrit, mtosys(i, :, :&
&                      ), uinf, mu, ncrit, gamma, rvj(i, :, :), rdxj(i, &
&                      :, :), rdyj(i, :, :), rudxj(i, :, :, :), rudyj(i&
&                      , :, :, :), rmass_l, rmomx_l, rmomz_l, ren_l, &
&                      rts_l)
      rmass(inds) = rmass(inds) + rmass_l
      rmomx(inds) = rmomx(inds) + rmomx_l
      rmomz(inds) = rmomz(inds) + rmomz_l
      ren(inds) = ren(inds) + ren_l
      rts(inds) = rts(inds) + rts_l
    END DO
  END SUBROUTINE MESH_GETRESIDUALS

END MODULE THREE_EQUATION_B

