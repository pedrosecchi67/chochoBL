!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.15 (master) - 15 Apr 2020 11:54
!
MODULE THREE_EQUATION_D
  USE ISO_C_BINDING
  IMPLICIT NONE
  REAL*8, PARAMETER :: eps=1e-15, log10eps=1.0000000000000022, expit_lim&
& = 709.7

CONTAINS
!  Differentiation of uwq in forward (tangent) mode:
!   variations   of useful results: qe u w
!   with respect to varying inputs: qx qy qz
  SUBROUTINE UWQ_D(qx, qxd, qy, qyd, qz, qzd, mtosys, u, ud, w, wd, qe, &
&   qed)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: qx(4), qy(4), qz(4), mtosys(3, 3)
    REAL*8, INTENT(IN) :: qxd(4), qyd(4), qzd(4)
    REAL*8, INTENT(OUT) :: u(4), w(4), qe(4)
    REAL*8, INTENT(OUT) :: ud(4), wd(4), qed(4)
    INTRINSIC SQRT
    REAL*8, DIMENSION(4) :: arg1
    REAL*8, DIMENSION(4) :: arg1d
    REAL*8, DIMENSION(4) :: temp
    arg1d(:) = 2*qx*qxd + 2*qy*qyd + 2*qz*qzd
    arg1(:) = qx**2 + qy**2 + qz**2
    temp = SQRT(arg1(:))
    WHERE (arg1(:) .EQ. 0.0) 
      qed = 0.0_8
    ELSEWHERE
      qed = arg1d(:)/(2.0*temp)
    END WHERE
    qe = temp
    ud = mtosys(1, 1)*qxd + mtosys(1, 2)*qyd + mtosys(1, 3)*qzd
    u = mtosys(1, 1)*qx + mtosys(1, 2)*qy + mtosys(1, 3)*qz
    wd = mtosys(3, 1)*qxd + mtosys(3, 2)*qyd + mtosys(3, 3)*qzd
    w = mtosys(3, 1)*qx + mtosys(3, 2)*qy + mtosys(3, 3)*qz
  END SUBROUTINE UWQ_D

  SUBROUTINE UWQ(qx, qy, qz, mtosys, u, w, qe)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: qx(4), qy(4), qz(4), mtosys(3, 3)
    REAL*8, INTENT(OUT) :: u(4), w(4), qe(4)
    INTRINSIC SQRT
    REAL*8, DIMENSION(4) :: arg1
    arg1(:) = qx**2 + qy**2 + qz**2
    qe = SQRT(arg1(:))
    u = mtosys(1, 1)*qx + mtosys(1, 2)*qy + mtosys(1, 3)*qz
    w = mtosys(3, 1)*qx + mtosys(3, 2)*qy + mtosys(3, 3)*qz
  END SUBROUTINE UWQ

!  Differentiation of mache in forward (tangent) mode:
!   variations   of useful results: m
!   with respect to varying inputs: qe
  SUBROUTINE MACHE_D(qe, qed, v_sonic, m, md)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: qe(4), v_sonic
    REAL*8, INTENT(IN) :: qed(4)
    REAL*8, INTENT(OUT) :: m(4)
    REAL*8, INTENT(OUT) :: md(4)
    md = qed/v_sonic
    m = qe/v_sonic
  END SUBROUTINE MACHE_D

  SUBROUTINE MACHE(qe, v_sonic, m)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: qe(4), v_sonic
    REAL*8, INTENT(OUT) :: m(4)
    m = qe/v_sonic
  END SUBROUTINE MACHE

!  Differentiation of rhoe in forward (tangent) mode:
!   variations   of useful results: rho
!   with respect to varying inputs: m
  SUBROUTINE RHOE_D(m, md, a, rho0, uinf, rho, rhod)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: m(4), a, rho0, uinf
    REAL*8, INTENT(IN) :: md(4)
    REAL*8, INTENT(OUT) :: rho(4)
    REAL*8, INTENT(OUT) :: rhod(4)
    REAL*8, DIMENSION(4) :: temp
    temp = m*m/uinf
    rhod = -(rho0*((a*m-uinf)*2*m/uinf+temp*a)*md)
    rho = rho0*(1.0-temp*(a*m-uinf))
  END SUBROUTINE RHOE_D

  SUBROUTINE RHOE(m, a, rho0, uinf, rho)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: m(4), a, rho0, uinf
    REAL*8, INTENT(OUT) :: rho(4)
    rho = (1.0-m**2*(m*a-uinf)/uinf)*rho0
  END SUBROUTINE RHOE

!  Differentiation of reth in forward (tangent) mode:
!   variations   of useful results: re
!   with respect to varying inputs: qe th11 rho
  SUBROUTINE RETH_D(qe, qed, rho, rhod, th11, th11d, mu, re, red)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: qe(4), rho(4), th11(4), mu
    REAL*8, INTENT(IN) :: qed(4), rhod(4), th11d(4)
    REAL*8, INTENT(OUT) :: re(4)
    REAL*8, INTENT(OUT) :: red(4)
    INTEGER :: i
    red = th11*(rho*qed+qe*rhod)/mu + qe*rho*th11d/mu
    re = qe*rho*th11/mu
    DO i=1,4
      IF (re(i) .LT. log10eps) THEN
        red(i) = 0.0_8
        re(i) = log10eps
      END IF
    END DO
  END SUBROUTINE RETH_D

  SUBROUTINE RETH(qe, rho, th11, mu, re)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: qe(4), rho(4), th11(4), mu
    REAL*8, INTENT(OUT) :: re(4)
    INTEGER :: i
    re = qe*rho*th11/mu
    DO i=1,4
      IF (re(i) .LT. log10eps) re(i) = log10eps
    END DO
  END SUBROUTINE RETH

!  Differentiation of expit in forward (tangent) mode:
!   variations   of useful results: sig
!   with respect to varying inputs: x
  SUBROUTINE EXPIT_D(x, xd, n, sig, sigd)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    REAL*8, INTENT(IN) :: x(n)
    REAL*8, INTENT(IN) :: xd(n)
    REAL*8, INTENT(OUT) :: sig(n)
    REAL*8, INTENT(OUT) :: sigd(n)
    INTEGER :: i
    INTRINSIC EXP
    REAL*8 :: temp
    sigd = 0.0_8
    DO i=1,n
      IF (x(i) .LT. -expit_lim) THEN
        sigd(i) = 0.0_8
        sig(i) = 0.0
      ELSE IF (x(i) .GT. expit_lim) THEN
        sigd(i) = 0.0_8
        sig(i) = 1.0
      ELSE
        temp = 1.0/(EXP(-x(i))+1.0)
        sigd(i) = temp*EXP(-x(i))*xd(i)/(EXP(-x(i))+1.0)
        sig(i) = temp
      END IF
    END DO
  END SUBROUTINE EXPIT_D

  SUBROUTINE EXPIT(x, n, sig)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    REAL*8, INTENT(IN) :: x(n)
    REAL*8, INTENT(OUT) :: sig(n)
    INTEGER :: i
    INTRINSIC EXP
    DO i=1,n
      IF (x(i) .LT. -expit_lim) THEN
        sig(i) = 0.0
      ELSE IF (x(i) .GT. expit_lim) THEN
        sig(i) = 1.0
      ELSE
        sig(i) = 1.0/(1.0+EXP(-x(i)))
      END IF
    END DO
  END SUBROUTINE EXPIT

!  Differentiation of rethcrit in forward (tangent) mode:
!   variations   of useful results: rethc
!   with respect to varying inputs: hk
  SUBROUTINE RETHCRIT_D(hk, hkd, rethc, rethcd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4)
    REAL*8, INTENT(IN) :: hkd(4)
    REAL*8, INTENT(OUT) :: rethc(4)
    REAL*8, INTENT(OUT) :: rethcd(4)
    INTRINSIC TANH
    REAL*8, DIMENSION(4) :: pwy1
    REAL*8, DIMENSION(4) :: pwy1d
    REAL*8, DIMENSION(4) :: temp
    REAL*8, DIMENSION(4) :: temp0
    REAL*8, DIMENSION(4) :: temp1
    temp = 20.0/(hk-1.0)
    temp0 = TANH(temp - 12.9)
    temp1 = 1.415/(hk-1.0)
    pwy1d = -((3.295/(hk-1.0)**2+temp0*temp1/(hk-1.0)+(temp1-0.489)*(1.0&
&     -TANH(temp-12.9)**2)*temp/(hk-1.0))*hkd)
    pwy1 = 3.295/(hk-1.0) + (temp1-0.489)*temp0 + 0.44
    temp1 = 10.0**pwy1
    rethcd = temp1*LOG(10.0)*pwy1d
    rethc = temp1
  END SUBROUTINE RETHCRIT_D

  SUBROUTINE RETHCRIT(hk, rethc)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4)
    REAL*8, INTENT(OUT) :: rethc(4)
    INTRINSIC TANH
    REAL*8, DIMENSION(4) :: pwy1
    pwy1 = 3.295/(hk-1.0) + 0.44 + (1.415/(hk-1.0)-0.489)*TANH(20.0/(hk-&
&     1.0)-12.9)
    rethc = 10.0**pwy1
  END SUBROUTINE RETHCRIT

!  Differentiation of dndreth in forward (tangent) mode:
!   variations   of useful results: dndr
!   with respect to varying inputs: hk rth rethc
  SUBROUTINE DNDRETH_D(rethc, rethcd, rth, rthd, hk, hkd, a, dndr, dndrd&
& )
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: rethc(4), rth(4), hk(4), a
    REAL*8, INTENT(IN) :: rethcd(4), rthd(4), hkd(4)
    REAL*8, INTENT(OUT) :: dndr(4)
    REAL*8, INTENT(OUT) :: dndrd(4)
    REAL*8 :: sg(4)
    REAL*8 :: sgd(4)
    INTRINSIC TANH
    INTRINSIC SQRT
    REAL*8, DIMENSION(4) :: arg1
    REAL*8, DIMENSION(4) :: arg1d
    REAL*8, DIMENSION(4) :: result1
    REAL*8, DIMENSION(4) :: result1d
    REAL*8, DIMENSION(4) :: temp
    CALL EXPIT_D(a*(rth-rethc), a*(rthd-rethcd), 4, sg, sgd)
    arg1d(:) = 2*(2.4*hk+2.5*TANH(1.5*hk-4.65)-3.7)*(2.5*(1.0-TANH(1.5*&
&     hk-4.65)**2)*1.5+2.4)*hkd
    arg1(:) = (2.4*hk-3.7+2.5*TANH(1.5*hk-4.65))**2 + 0.15
    temp = SQRT(arg1(:))
    WHERE (arg1(:) .EQ. 0.0) 
      result1d = 0.0_8
    ELSEWHERE
      result1d = arg1d(:)/(2.0*temp)
    END WHERE
    result1 = temp
    dndrd = 0.01*(sg*result1d+result1*sgd)
    dndr = 0.01*result1*sg
  END SUBROUTINE DNDRETH_D

  SUBROUTINE DNDRETH(rethc, rth, hk, a, dndr)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: rethc(4), rth(4), hk(4), a
    REAL*8, INTENT(OUT) :: dndr(4)
    REAL*8 :: sg(4)
    INTRINSIC TANH
    INTRINSIC SQRT
    REAL*8, DIMENSION(4) :: arg1
    REAL*8, DIMENSION(4) :: result1
    CALL EXPIT(a*(rth-rethc), 4, sg)
    arg1(:) = (2.4*hk-3.7+2.5*TANH(1.5*hk-4.65))**2 + 0.15
    result1 = SQRT(arg1(:))
    dndr = 0.01*result1*sg
  END SUBROUTINE DNDRETH

!  Differentiation of p_trans in forward (tangent) mode:
!   variations   of useful results: p
!   with respect to varying inputs: hk rth th11
  SUBROUTINE P_TRANS_D(rth, rthd, hk, hkd, th11, th11d, a, p, pd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: rth(4), hk(4), th11(4), a
    REAL*8, INTENT(IN) :: rthd(4), hkd(4), th11d(4)
    REAL*8, INTENT(OUT) :: p(4)
    REAL*8, INTENT(OUT) :: pd(4)
    REAL*8 :: rthc(4), dndr(4), m(4), l(4)
    REAL*8 :: rthcd(4), dndrd(4), md(4), ld(4)
    REAL*8, DIMENSION(4) :: temp
    REAL*8, DIMENSION(4) :: temp0
    CALL RETHCRIT_D(hk, hkd, rthc, rthcd)
    CALL DNDRETH_D(rthc, rthcd, rth, rthd, hk, hkd, a, dndr, dndrd)
    temp = (6.54*hk-14.07)/(hk*hk)
    ld = (6.54-temp*2*hk)*hkd/hk**2
    l = temp
    temp = (hk-4.0)*(hk-4.0)/(hk-1.0)
    temp0 = (0.058*temp-0.068)/l
    md = (0.058*(2*hk-2*4.0-temp)*hkd/(hk-1.0)-temp0*ld)/l
    m = temp0
    temp0 = (m+1.0)/(2*th11)
    pd = temp0*(l*dndrd+dndr*ld) + dndr*l*(md-temp0*2*th11d)/(2*th11)
    p = dndr*l*temp0
  END SUBROUTINE P_TRANS_D

  SUBROUTINE P_TRANS(rth, hk, th11, a, p)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: rth(4), hk(4), th11(4), a
    REAL*8, INTENT(OUT) :: p(4)
    REAL*8 :: rthc(4), dndr(4), m(4), l(4)
    CALL RETHCRIT(hk, rthc)
    CALL DNDRETH(rthc, rth, hk, a, dndr)
    l = (6.54*hk-14.07)/hk**2
    m = (0.058*(hk-4.0)**2/(hk-1.0)-0.068)/l
    p = dndr*((m+1.0)/2)*l/th11
  END SUBROUTINE P_TRANS

!  Differentiation of hk_closure in forward (tangent) mode:
!   variations   of useful results: hk
!   with respect to varying inputs: h me
  SUBROUTINE HK_CLOSURE_D(h, hd, me, med, hk, hkd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: h(4), me(4)
    REAL*8, INTENT(IN) :: hd(4), med(4)
    REAL*8, INTENT(OUT) :: hk(4)
    REAL*8, INTENT(OUT) :: hkd(4)
    REAL*8, DIMENSION(4) :: temp
    temp = (h-0.290*(me*me))/(0.113*(me*me)+1.0)
    hkd = (hd-(0.290*2*me+temp*0.113*2*me)*med)/(0.113*me**2+1.0)
    hk = temp
  END SUBROUTINE HK_CLOSURE_D

  SUBROUTINE HK_CLOSURE(h, me, hk)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: h(4), me(4)
    REAL*8, INTENT(OUT) :: hk(4)
    hk = (h-0.290*me**2)/(1.0+0.113*me**2)
  END SUBROUTINE HK_CLOSURE

!  Differentiation of hstar_laminar in forward (tangent) mode:
!   variations   of useful results: hst
!   with respect to varying inputs: hst hk
  SUBROUTINE HSTAR_LAMINAR_D(hk, hkd, hst, hstd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4)
    REAL*8, INTENT(IN) :: hkd(4)
    REAL*8, INTENT(OUT) :: hst(4)
    REAL*8, INTENT(OUT) :: hstd(4)
    INTEGER :: i
    REAL*8 :: temp
    DO i=1,4
      IF (hk(i) .LT. 4.0) THEN
        temp = (-hk(i)+4.0)*(-hk(i)+4.0)/hk(i)
        hstd(i) = -(0.076*(2*4.0-2*hk(i)+temp)*hkd(i)/hk(i))
        hst(i) = 0.076*temp + 1.515
      ELSE
        temp = (hk(i)-4.0)*(hk(i)-4.0)/hk(i)
        hstd(i) = 0.04*(2*hk(i)-2*4.0-temp)*hkd(i)/hk(i)
        hst(i) = 0.04*temp + 1.515
      END IF
    END DO
  END SUBROUTINE HSTAR_LAMINAR_D

  SUBROUTINE HSTAR_LAMINAR(hk, hst)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4)
    REAL*8, INTENT(OUT) :: hst(4)
    INTEGER :: i
    DO i=1,4
      IF (hk(i) .LT. 4.0) THEN
        hst(i) = 0.076*(4.0-hk(i))**2/hk(i) + 1.515
      ELSE
        hst(i) = 0.04*(hk(i)-4.0)**2/hk(i) + 1.515
      END IF
    END DO
  END SUBROUTINE HSTAR_LAMINAR

!  Differentiation of cf_laminar in forward (tangent) mode:
!   variations   of useful results: cf
!   with respect to varying inputs: hk rth
  SUBROUTINE CF_LAMINAR_D(hk, hkd, rth, rthd, cf, cfd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), rth(4)
    REAL*8, INTENT(IN) :: hkd(4), rthd(4)
    REAL*8, INTENT(OUT) :: cf(4)
    REAL*8, INTENT(OUT) :: cfd(4)
    REAL*8 :: tau(4)
    REAL*8 :: taud(4)
    INTEGER :: i
    REAL*8 :: temp
    taud = 0.0_8
    DO i=1,4
      IF (hk(i) .LT. 7.4) THEN
        temp = (-hk(i)+7.4)*(-hk(i)+7.4)/(hk(i)-1.0)
        taud(i) = -(0.0396*(2*7.4-2*hk(i)+temp)*hkd(i)/(hk(i)-1.0))
        tau(i) = 0.0396*temp - 0.134
      ELSE
        temp = 1.4/(hk(i)-6.0)
        taud(i) = 0.044*2*(1.0-temp)*temp*hkd(i)/(hk(i)-6.0)
        tau(i) = 0.044*((1.0-temp)*(1.0-temp)) - 0.134
      END IF
    END DO
    cfd = (taud-tau*rthd/rth)/rth
    cf = tau/rth
  END SUBROUTINE CF_LAMINAR_D

  SUBROUTINE CF_LAMINAR(hk, rth, cf)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), rth(4)
    REAL*8, INTENT(OUT) :: cf(4)
    REAL*8 :: tau(4)
    INTEGER :: i
    DO i=1,4
      IF (hk(i) .LT. 7.4) THEN
        tau(i) = 0.0396*(7.4-hk(i))**2/(hk(i)-1.0) - 0.134
      ELSE
        tau(i) = 0.044*(1.0-1.4/(hk(i)-6.0))**2 - 0.134
      END IF
    END DO
    cf = tau/rth
  END SUBROUTINE CF_LAMINAR

!  Differentiation of hprime_laminar in forward (tangent) mode:
!   variations   of useful results: hpr
!   with respect to varying inputs: hk me
  SUBROUTINE HPRIME_LAMINAR_D(me, med, hk, hkd, hpr, hprd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: me(4), hk(4)
    REAL*8, INTENT(IN) :: med(4), hkd(4)
    REAL*8, INTENT(OUT) :: hpr(4)
    REAL*8, INTENT(OUT) :: hprd(4)
    REAL*8, DIMENSION(4) :: temp
    temp = 0.064/(hk-0.8)
    hprd = (temp+0.251)*2*me*med - me**2*temp*hkd/(hk-0.8)
    hpr = me*me*(temp+0.251)
  END SUBROUTINE HPRIME_LAMINAR_D

  SUBROUTINE HPRIME_LAMINAR(me, hk, hpr)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: me(4), hk(4)
    REAL*8, INTENT(OUT) :: hpr(4)
    hpr = me**2*(0.251+0.064/(hk-0.8))
  END SUBROUTINE HPRIME_LAMINAR

!  Differentiation of cd_laminar in forward (tangent) mode:
!   variations   of useful results: cd
!   with respect to varying inputs: hst hk rth
  SUBROUTINE CD_LAMINAR_D(hst, hstd, hk, hkd, rth, rthd, cd, cdd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hst(4), hk(4), rth(4)
    REAL*8, INTENT(IN) :: hstd(4), hkd(4), rthd(4)
    REAL*8, INTENT(OUT) :: cd(4)
    REAL*8, INTENT(OUT) :: cdd(4)
    REAL*8 :: d(4)
    REAL*8 :: dd(4)
    INTEGER :: i
    REAL*8 :: temp
    REAL*8 :: temp0
    REAL*8, DIMENSION(4) :: temp1
    dd = 0.0_8
    DO i=1,4
      IF (hk(i) .LT. 4.0) THEN
        dd(i) = -(0.001025*5.5*(4.0-hk(i))**4.5*hkd(i))
        d(i) = 0.001025*(4.0-hk(i))**5.5 + 0.1035
      ELSE
        temp = 0.02*((hk(i)-4.0)*(hk(i)-4.0)) + 1.0
        temp0 = (hk(i)-4.0)*(hk(i)-4.0)/temp
        dd(i) = -(0.003*(2*hk(i)-2*4.0-temp0*0.02*2*(hk(i)-4.0))*hkd(i)/&
&         (2.0*temp))
        d(i) = (0.207-0.003*temp0)/2.0
      END IF
    END DO
    temp1 = d*hst/rth
    cdd = (hst*dd+d*hstd-temp1*rthd)/rth
    cd = temp1
  END SUBROUTINE CD_LAMINAR_D

  SUBROUTINE CD_LAMINAR(hst, hk, rth, cd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hst(4), hk(4), rth(4)
    REAL*8, INTENT(OUT) :: cd(4)
    REAL*8 :: d(4)
    INTEGER :: i
    DO i=1,4
      IF (hk(i) .LT. 4.0) THEN
        d(i) = 0.001025*(4.0-hk(i))**5.5 + 0.1035
      ELSE
        d(i) = (0.207-0.003*(hk(i)-4.0)**2/(1.0+0.02*(hk(i)-4.0)**2))/&
&         2.0
      END IF
    END DO
    cd = d*hst/rth
  END SUBROUTINE CD_LAMINAR

!  Differentiation of hstar_turbulent in forward (tangent) mode:
!   variations   of useful results: hst
!   with respect to varying inputs: hk me
  SUBROUTINE HSTAR_TURBULENT_D(hk, hkd, me, med, hst, hstd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), me(4)
    REAL*8, INTENT(IN) :: hkd(4), med(4)
    REAL*8, INTENT(OUT) :: hst(4)
    REAL*8, INTENT(OUT) :: hstd(4)
    REAL*8 :: hstme0(4)
    REAL*8 :: hstme0d(4)
    INTRINSIC EXP
    INTRINSIC ATAN
    INTRINSIC TANH
    INTRINSIC SQRT
    REAL*8, DIMENSION(4) :: pwy1
    REAL*8, DIMENSION(4) :: pwy1d
    REAL*8, DIMENSION(4) :: pwr1
    REAL*8, DIMENSION(4) :: pwr1d
    REAL*8, DIMENSION(4) :: pwy2
    REAL*8, DIMENSION(4) :: pwy2d
    REAL*8, DIMENSION(4) :: pwr2
    REAL*8, DIMENSION(4) :: pwr2d
    REAL*8, DIMENSION(4) :: arg1
    REAL*8, DIMENSION(4) :: arg1d
    REAL*8, DIMENSION(4) :: result1
    REAL*8, DIMENSION(4) :: result1d
    REAL*8, DIMENSION(4) :: temp
    pwy1d = -hkd
    pwy1 = 7.0 - hk
    temp = 10.0**pwy1
    pwr1d = temp*LOG(10.0)*pwy1d
    pwr1 = temp
    pwy2d = -(1.46*hkd)
    pwy2 = 4.0 - 1.46*hk
    temp = 10.0**pwy2
    pwr2d = temp*LOG(10.0)*pwy2d
    pwr2 = temp
    arg1d(:) = (1.0-TANH(2.14*pwr2)**2)*2.14*pwr2d
    arg1(:) = TANH(2.14*pwr2)
    temp = SQRT(arg1(:))
    WHERE (arg1(:) .EQ. 0.0) 
      result1d = 0.0_8
    ELSEWHERE
      result1d = arg1d(:)/(2.0*temp)
    END WHERE
    result1 = temp
    hstme0d = -(3.84*EXP((-2)*hk)*2*hkd) - pwr1d/(8.55*(1.0+((pwr1-1.0)/&
&     1.23)**2)*1.23) - 0.146*result1d
    hstme0 = 1.81 + 3.84*EXP(-(2*hk)) - ATAN((pwr1-1.0)/1.23)/8.55 - &
&     0.146*result1
    temp = (hstme0+0.028*(me*me))/(0.014*(me*me)+1.0)
    hstd = (hstme0d+(0.028*2*me-temp*0.014*2*me)*med)/(0.014*me**2+1.0)
    hst = temp
  END SUBROUTINE HSTAR_TURBULENT_D

  SUBROUTINE HSTAR_TURBULENT(hk, me, hst)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), me(4)
    REAL*8, INTENT(OUT) :: hst(4)
    REAL*8 :: hstme0(4)
    INTRINSIC EXP
    INTRINSIC ATAN
    INTRINSIC TANH
    INTRINSIC SQRT
    REAL*8, DIMENSION(4) :: pwy1
    REAL*8, DIMENSION(4) :: pwr1
    REAL*8, DIMENSION(4) :: pwy2
    REAL*8, DIMENSION(4) :: pwr2
    REAL*8, DIMENSION(4) :: arg1
    REAL*8, DIMENSION(4) :: result1
    pwy1 = 7.0 - hk
    pwr1 = 10.0**pwy1
    pwy2 = 4.0 - 1.46*hk
    pwr2 = 10.0**pwy2
    arg1(:) = TANH(2.14*pwr2)
    result1 = SQRT(arg1(:))
    hstme0 = 1.81 + 3.84*EXP(-(2*hk)) - ATAN((pwr1-1.0)/1.23)/8.55 - &
&     0.146*result1
    hst = (hstme0+0.028*me**2)/(1.0+0.014*me**2)
  END SUBROUTINE HSTAR_TURBULENT

!  Differentiation of hprime_turbulent in forward (tangent) mode:
!   variations   of useful results: hpr
!   with respect to varying inputs: hk me
  SUBROUTINE HPRIME_TURBULENT_D(me, med, hk, hkd, hpr, hprd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: me(4), hk(4)
    REAL*8, INTENT(IN) :: med(4), hkd(4)
    REAL*8, INTENT(OUT) :: hpr(4)
    REAL*8, INTENT(OUT) :: hprd(4)
    REAL*8, DIMENSION(4) :: temp
    temp = 0.064/(hk-0.8)
    hprd = (temp+0.251)*2*me*med - me**2*temp*hkd/(hk-0.8)
    hpr = me*me*(temp+0.251)
  END SUBROUTINE HPRIME_TURBULENT_D

  SUBROUTINE HPRIME_TURBULENT(me, hk, hpr)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: me(4), hk(4)
    REAL*8, INTENT(OUT) :: hpr(4)
    hpr = me**2*(0.251+0.064/(hk-0.8))
  END SUBROUTINE HPRIME_TURBULENT

!  Differentiation of fc in forward (tangent) mode:
!   variations   of useful results: f
!   with respect to varying inputs: me
  SUBROUTINE FC_D(me, med, gamma, f, fd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: me(4), gamma
    REAL*8, INTENT(IN) :: med(4)
    REAL*8, INTENT(OUT) :: f(4)
    REAL*8, INTENT(OUT) :: fd(4)
    INTRINSIC SQRT
    REAL*8, DIMENSION(4) :: arg1
    REAL*8, DIMENSION(4) :: arg1d
    REAL*8, DIMENSION(4) :: temp
    arg1d(:) = (gamma-1.0)*me*med
    arg1(:) = 1.0 + (gamma-1.0)*me**2/2
    temp = SQRT(arg1(:))
    WHERE (arg1(:) .EQ. 0.0) 
      fd = 0.0_8
    ELSEWHERE
      fd = arg1d(:)/(2.0*temp)
    END WHERE
    f = temp
  END SUBROUTINE FC_D

  SUBROUTINE FC(me, gamma, f)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: me(4), gamma
    REAL*8, INTENT(OUT) :: f(4)
    INTRINSIC SQRT
    REAL*8, DIMENSION(4) :: arg1
    arg1(:) = 1.0 + (gamma-1.0)*me**2/2
    f = SQRT(arg1(:))
  END SUBROUTINE FC

!  Differentiation of cf_turbulent in forward (tangent) mode:
!   variations   of useful results: cf
!   with respect to varying inputs: f hk rth
  SUBROUTINE CF_TURBULENT_D(hk, hkd, rth, rthd, f, fd, cf, cfd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), rth(4), f(4)
    REAL*8, INTENT(IN) :: hkd(4), rthd(4), fd(4)
    REAL*8, INTENT(OUT) :: cf(4)
    REAL*8, INTENT(OUT) :: cfd(4)
    REAL*8 :: cf_bar(4)
    REAL*8 :: cf_bard(4)
    INTRINSIC LOG10
    INTRINSIC EXP
    INTRINSIC TANH
    REAL*8, DIMENSION(4) :: pwx1
    REAL*8, DIMENSION(4) :: pwx1d
    REAL*8, DIMENSION(4) :: pwy1
    REAL*8, DIMENSION(4) :: pwy1d
    REAL*8, DIMENSION(4) :: pwr1
    REAL*8, DIMENSION(4) :: pwr1d
    REAL*8, DIMENSION(4) :: arg1
    REAL*8, DIMENSION(4) :: arg1d
    REAL*8, DIMENSION(4) :: temp
    pwx1d = rthd/(rth*LOG(10.0))
    pwx1 = LOG10(rth)
    pwy1d = -(0.31*hkd)
    pwy1 = -(0.31*hk) - 1.74
    temp = pwx1**pwy1
    WHERE (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))&
&   ) 
      pwr1d = 0.0_8
    ELSEWHERE (pwx1 .LE. 0.0) 
      pwr1d = pwy1*pwx1**(pwy1-1)*pwx1d
    ELSEWHERE
      pwr1d = pwy1*pwx1**(pwy1-1)*pwx1d + temp*LOG(pwx1)*pwy1d
    END WHERE
    pwr1 = temp
    arg1d(:) = -(8.0*hkd/7.0)
    arg1(:) = 4.0 - 8.0*hk/7.0
    temp = EXP(-(1.33*hk))
    cf_bard = 0.3*(temp*pwr1d-pwr1*EXP(-(1.33*hk))*1.33*hkd) + 0.00011*(&
&     1.0-TANH(arg1(:))**2)*arg1d(:)
    cf_bar = 0.3*(pwr1*temp) + 0.00011*(TANH(arg1(:))-1.0)
    cfd = (cf_bard-cf_bar*fd/f)/f
    cf = cf_bar/f
  END SUBROUTINE CF_TURBULENT_D

  SUBROUTINE CF_TURBULENT(hk, rth, f, cf)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), rth(4), f(4)
    REAL*8, INTENT(OUT) :: cf(4)
    REAL*8 :: cf_bar(4)
    INTRINSIC LOG10
    INTRINSIC EXP
    INTRINSIC TANH
    REAL*8, DIMENSION(4) :: pwx1
    REAL*8, DIMENSION(4) :: pwy1
    REAL*8, DIMENSION(4) :: pwr1
    REAL*8, DIMENSION(4) :: arg1
    pwx1 = LOG10(rth)
    pwy1 = -(0.31*hk) - 1.74
    pwr1 = pwx1**pwy1
    arg1(:) = 4.0 - 8.0*hk/7.0
    cf_bar = 0.3*pwr1*EXP(-(1.33*hk)) + 0.00011*(TANH(arg1(:))-1.0)
    cf = cf_bar/f
  END SUBROUTINE CF_TURBULENT

!  Differentiation of cd_turbulent in forward (tangent) mode:
!   variations   of useful results: cd
!   with respect to varying inputs: f hk rth me
  SUBROUTINE CD_TURBULENT_D(hk, hkd, f, fd, me, med, rth, rthd, cd, cdd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), f(4), me(4), rth(4)
    REAL*8, INTENT(IN) :: hkd(4), fd(4), med(4), rthd(4)
    REAL*8, INTENT(OUT) :: cd(4)
    REAL*8, INTENT(OUT) :: cdd(4)
    REAL*8 :: a(4), b(4), c(4)
    REAL*8 :: ad(4), bd(4), cd0(4)
    INTEGER :: i
    INTRINSIC EXP
    REAL*8, DIMENSION(4) :: arg1
    REAL*8, DIMENSION(4) :: arg1d
    REAL*8, DIMENSION(4) :: arg2
    REAL*8, DIMENSION(4) :: arg2d
    REAL*8, DIMENSION(4) :: pwr1
    REAL*8, DIMENSION(4) :: pwr1d
    REAL*8, DIMENSION(4) :: temp
    ad = 0.0_8
    DO i=1,4
      IF (hk(i) .LT. 3.5) THEN
        ad(i) = 0.160*hkd(i)
        a(i) = 0.160*(hk(i)-3.5) - 0.550
      ELSE
        ad(i) = -(0.280*hkd(i))
        a(i) = 0.438 - 0.280*hk(i)
      END IF
    END DO
    arg1d(:) = -(0.15*2.1*hk**1.1*hkd)
    arg1(:) = -(0.15*hk**2.1)
    arg2d(:) = 0.117*2*hk*hkd
    arg2(:) = 0.117*hk**2
    bd = 3e-5*EXP(arg2(:))*arg2d(:) - 0.011*EXP(arg1(:))*arg1d(:)
    b = 0.009 - 0.011*EXP(arg1(:)) + 3e-5*EXP(arg2(:))
    temp = 0.05*me**1.4 + 1.0
    cd0 = temp*fd + f*0.05*1.4*me**0.4*med
    c = f*temp
    pwr1d = -(0.574*rth**(-1.574)*rthd)
    pwr1 = rth**(-0.574)
    temp = (b+a*pwr1)/c
    cdd = 2*(bd+pwr1*ad+a*pwr1d-temp*cd0)/c
    cd = 2*temp
  END SUBROUTINE CD_TURBULENT_D

  SUBROUTINE CD_TURBULENT(hk, f, me, rth, cd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hk(4), f(4), me(4), rth(4)
    REAL*8, INTENT(OUT) :: cd(4)
    REAL*8 :: a(4), b(4), c(4)
    INTEGER :: i
    INTRINSIC EXP
    REAL*8, DIMENSION(4) :: arg1
    REAL*8, DIMENSION(4) :: arg2
    REAL*8, DIMENSION(4) :: pwr1
    DO i=1,4
      IF (hk(i) .LT. 3.5) THEN
        a(i) = 0.160*(hk(i)-3.5) - 0.550
      ELSE
        a(i) = 0.438 - 0.280*hk(i)
      END IF
    END DO
    arg1(:) = -(0.15*hk**2.1)
    arg2(:) = 0.117*hk**2
    b = 0.009 - 0.011*EXP(arg1(:)) + 3e-5*EXP(arg2(:))
    c = f*(1.0+0.05*me**1.4)
    pwr1 = rth**(-0.574)
    cd = 2*(b+a*pwr1)/c
  END SUBROUTINE CD_TURBULENT

!  Differentiation of sigma_n in forward (tangent) mode:
!   variations   of useful results: sn
!   with respect to varying inputs: nts
  SUBROUTINE SIGMA_N_D(nts, ntsd, a, ncrit, sn, snd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: nts(4), a, ncrit
    REAL*8, INTENT(IN) :: ntsd(4)
    REAL*8, INTENT(OUT) :: sn(4)
    REAL*8, INTENT(OUT) :: snd(4)
    CALL EXPIT_D(a*(nts-ncrit), a*ntsd, 4, sn, snd)
  END SUBROUTINE SIGMA_N_D

  SUBROUTINE SIGMA_N(nts, a, ncrit, sn)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: nts(4), a, ncrit
    REAL*8, INTENT(OUT) :: sn(4)
    CALL EXPIT(a*(nts-ncrit), 4, sn)
  END SUBROUTINE SIGMA_N

!  Differentiation of a_crossflow in forward (tangent) mode:
!   variations   of useful results: a
!   with respect to varying inputs: cf beta me
  SUBROUTINE A_CROSSFLOW_D(cf, cfd, beta, betad, me, med, a, ad)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: cf(4), beta(4), me(4)
    REAL*8, INTENT(IN) :: cfd(4), betad(4), med(4)
    REAL*8, INTENT(OUT) :: a(4)
    REAL*8, INTENT(OUT) :: ad(4)
    REAL*8 :: g(4)
    REAL*8 :: gd(4)
    INTRINSIC COS
    INTRINSIC SQRT
    INTRINSIC TAN
    REAL*8, DIMENSION(4) :: arg1
    REAL*8, DIMENSION(4) :: arg1d
    REAL*8, DIMENSION(4) :: temp
    REAL*8, DIMENSION(4) :: temp0
    temp = 0.18*(me*me) + 1.0
    temp0 = COS(beta)
    arg1d(:) = temp0*(temp*cfd+cf*0.18*2*me*med) - cf*temp*SIN(beta)*&
&     betad
    arg1(:) = temp0*(cf*temp)
    temp0 = SQRT(arg1(:))
    WHERE (arg1(:) .EQ. 0.0) 
      gd = 0.0_8
    ELSEWHERE
      gd = arg1d(:)/(2.0*temp0)
    END WHERE
    g = temp0
    temp0 = g/(g-1.0)
    temp = TAN(beta)
    ad = (temp0+1.0)*(1.0+TAN(beta)**2)*betad + temp*(1.0-temp0)*gd/(g-&
&     1.0)
    a = temp*(temp0+1.0)
  END SUBROUTINE A_CROSSFLOW_D

  SUBROUTINE A_CROSSFLOW(cf, beta, me, a)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: cf(4), beta(4), me(4)
    REAL*8, INTENT(OUT) :: a(4)
    REAL*8 :: g(4)
    INTRINSIC COS
    INTRINSIC SQRT
    INTRINSIC TAN
    REAL*8, DIMENSION(4) :: arg1
    arg1(:) = cf*COS(beta)*(1.0+0.18*me**2)
    g = SQRT(arg1(:))
    a = TAN(beta)*(g/(g-1.0)+1.0)
  END SUBROUTINE A_CROSSFLOW

!  Differentiation of deltastar_innode in forward (tangent) mode:
!   variations   of useful results: deltastar_1 deltastar_2
!   with respect to varying inputs: h th11 a
  SUBROUTINE DELTASTAR_INNODE_D(th11, th11d, h, hd, a, ad, deltastar_1, &
&   deltastar_1d, deltastar_2, deltastar_2d)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: th11(4), h(4), a(4)
    REAL*8, INTENT(IN) :: th11d(4), hd(4), ad(4)
    REAL*8, INTENT(OUT) :: deltastar_1(4), deltastar_2(4)
    REAL*8, INTENT(OUT) :: deltastar_1d(4), deltastar_2d(4)
    deltastar_1d = th11*hd + h*th11d
    deltastar_1 = h*th11
    deltastar_2d = -(deltastar_1*ad+a*deltastar_1d)
    deltastar_2 = -(a*deltastar_1)
  END SUBROUTINE DELTASTAR_INNODE_D

  SUBROUTINE DELTASTAR_INNODE(th11, h, a, deltastar_1, deltastar_2)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: th11(4), h(4), a(4)
    REAL*8, INTENT(OUT) :: deltastar_1(4), deltastar_2(4)
    deltastar_1 = h*th11
    deltastar_2 = -(a*deltastar_1)
  END SUBROUTINE DELTASTAR_INNODE

!  Differentiation of theta_innode in forward (tangent) mode:
!   variations   of useful results: th22 th12 th21
!   with respect to varying inputs: th11 deltastar_2 a
  SUBROUTINE THETA_INNODE_D(th11, th11d, a, ad, deltastar_2, &
&   deltastar_2d, th12, th12d, th21, th21d, th22, th22d)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: th11(4), a(4), deltastar_2(4)
    REAL*8, INTENT(IN) :: th11d(4), ad(4), deltastar_2d(4)
    REAL*8, INTENT(OUT) :: th12(4), th21(4), th22(4)
    REAL*8, INTENT(OUT) :: th12d(4), th21d(4), th22d(4)
    th21d = -(th11*ad+a*th11d)
    th21 = -(a*th11)
    th12d = th21d - deltastar_2d
    th12 = th21 - deltastar_2
    th22d = -(th12*ad+a*th12d)
    th22 = -(a*th12)
  END SUBROUTINE THETA_INNODE_D

  SUBROUTINE THETA_INNODE(th11, a, deltastar_2, th12, th21, th22)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: th11(4), a(4), deltastar_2(4)
    REAL*8, INTENT(OUT) :: th12(4), th21(4), th22(4)
    th21 = -(a*th11)
    th12 = th21 - deltastar_2
    th22 = -(a*th12)
  END SUBROUTINE THETA_INNODE

!  Differentiation of thetastar_innode in forward (tangent) mode:
!   variations   of useful results: thst1 thst2
!   with respect to varying inputs: th22 hst th11 deltastar_1 a
  SUBROUTINE THETASTAR_INNODE_D(hst, hstd, a, ad, deltastar_1, &
&   deltastar_1d, th11, th11d, th22, th22d, thst1, thst1d, thst2, thst2d&
& )
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hst(4), a(4), deltastar_1(4), th11(4), th22(4)
    REAL*8, INTENT(IN) :: hstd(4), ad(4), deltastar_1d(4), th11d(4), &
&   th22d(4)
    REAL*8, INTENT(OUT) :: thst1(4), thst2(4)
    REAL*8, INTENT(OUT) :: thst1d(4), thst2d(4)
    thst1d = th11*hstd + hst*th11d
    thst1 = hst*th11
    thst2d = (deltastar_1+th11+th22-thst1)*ad + a*(deltastar_1d+th11d+&
&     th22d-thst1d)
    thst2 = a*(deltastar_1+th11+th22-thst1)
  END SUBROUTINE THETASTAR_INNODE_D

  SUBROUTINE THETASTAR_INNODE(hst, a, deltastar_1, th11, th22, thst1, &
&   thst2)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hst(4), a(4), deltastar_1(4), th11(4), th22(4)
    REAL*8, INTENT(OUT) :: thst1(4), thst2(4)
    thst1 = hst*th11
    thst2 = a*(deltastar_1+th11+th22-thst1)
  END SUBROUTINE THETASTAR_INNODE

!  Differentiation of deltaprime_innode in forward (tangent) mode:
!   variations   of useful results: deltaprime_1 deltaprime_2
!   with respect to varying inputs: hpr th11 a
  SUBROUTINE DELTAPRIME_INNODE_D(hpr, hprd, a, ad, th11, th11d, &
&   deltaprime_1, deltaprime_1d, deltaprime_2, deltaprime_2d)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hpr(4), a(4), th11(4)
    REAL*8, INTENT(IN) :: hprd(4), ad(4), th11d(4)
    REAL*8, INTENT(OUT) :: deltaprime_1(4), deltaprime_2(4)
    REAL*8, INTENT(OUT) :: deltaprime_1d(4), deltaprime_2d(4)
    deltaprime_1d = th11*hprd + hpr*th11d
    deltaprime_1 = hpr*th11
    deltaprime_2d = -(deltaprime_1*ad+a*deltaprime_1d)
    deltaprime_2 = -(a*deltaprime_1)
  END SUBROUTINE DELTAPRIME_INNODE_D

  SUBROUTINE DELTAPRIME_INNODE(hpr, a, th11, deltaprime_1, deltaprime_2)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hpr(4), a(4), th11(4)
    REAL*8, INTENT(OUT) :: deltaprime_1(4), deltaprime_2(4)
    deltaprime_1 = hpr*th11
    deltaprime_2 = -(a*deltaprime_1)
  END SUBROUTINE DELTAPRIME_INNODE

!  Differentiation of cd_innode in forward (tangent) mode:
!   variations   of useful results: cd_2
!   with respect to varying inputs: cd a
  SUBROUTINE CD_INNODE_D(cd, cdd, a, ad, cd_2, cd_2d)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: cd(4), a(4)
    REAL*8, INTENT(IN) :: cdd(4), ad(4)
    REAL*8, INTENT(OUT) :: cd_2(4)
    REAL*8, INTENT(OUT) :: cd_2d(4)
    REAL*8 :: a_aux(4), base, lbase, eden, enum, expon
    REAL*8 :: based, edend, enumd, expond
    INTEGER :: i
    INTRINSIC ABS
    INTRINSIC LOG
    REAL*8 :: temp
    WHERE (a .GE. 0.0) 
      a_aux = a
    ELSEWHERE
      a_aux = -a
    END WHERE
    cd_2d = 0.0_8
    DO i=1,4
      based = 14667.0*cdd(i)
      base = 14667.0*cd(i) + 3.0
      IF (a_aux(i) .GT. 1e-15) THEN
        lbase = LOG(base)
        edend = 1020.0*cdd(i)
        eden = 1020.0*cd(i) + 4.0
        enumd = ad(i)
        enum = a(i) + 10.0
        expond = (enumd-enum*edend/eden)/eden
        expon = enum/eden
        temp = base**expon
        IF (base .LE. 0.0 .AND. (expon .EQ. 0.0 .OR. expon .NE. INT(&
&           expon))) THEN
          cd_2d = 0.0_8
        ELSE IF (base .LE. 0.0) THEN
          cd_2d = expon*base**(expon-1)*based
        ELSE
          cd_2d = expon*base**(expon-1)*based + temp*LOG(base)*expond
        END IF
        cd_2 = temp
      END IF
    END DO
  END SUBROUTINE CD_INNODE_D

  SUBROUTINE CD_INNODE(cd, a, cd_2)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: cd(4), a(4)
    REAL*8, INTENT(OUT) :: cd_2(4)
    REAL*8 :: a_aux(4), base, lbase, eden, enum, expon
    INTEGER :: i
    INTRINSIC ABS
    INTRINSIC LOG
    WHERE (a .GE. 0.0) 
      a_aux = a
    ELSEWHERE
      a_aux = -a
    END WHERE
    DO i=1,4
      base = 14667.0*cd(i) + 3.0
      IF (a_aux(i) .GT. 1e-15) THEN
        lbase = LOG(base)
        eden = 1020.0*cd(i) + 4.0
        enum = a(i) + 10.0
        expon = enum/eden
        cd_2 = base**expon
      END IF
    END DO
  END SUBROUTINE CD_INNODE

!  Differentiation of j_innode in forward (tangent) mode:
!   variations   of useful results: jxx jxz jzx jzz
!   with respect to varying inputs: th22 u w th11 th12 rho th21
  SUBROUTINE J_INNODE_D(th11, th11d, th12, th12d, th21, th21d, th22, &
&   th22d, u, ud, w, wd, rho, rhod, jxx, jxxd, jxz, jxzd, jzx, jzxd, jzz&
&   , jzzd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: th11(4), th12(4), th21(4), th22(4), u(4), w(4)&
&   , rho(4)
    REAL*8, INTENT(IN) :: th11d(4), th12d(4), th21d(4), th22d(4), ud(4)&
&   , wd(4), rhod(4)
    REAL*8, INTENT(OUT) :: jxx(4), jxz(4), jzx(4), jzz(4)
    REAL*8, INTENT(OUT) :: jxxd(4), jxzd(4), jzxd(4), jzzd(4)
    REAL*8 :: u2(4), uw(4), w2(4)
    REAL*8 :: u2d(4), uwd(4), w2d(4)
    REAL*8, DIMENSION(4) :: temp
    u2d = 2*u*ud
    u2 = u**2
    uwd = w*ud + u*wd
    uw = u*w
    w2d = 2*w*wd
    w2 = w**2
    temp = u2*th11 - uw*th12 + w2*th22 - uw*th21
    jxxd = rho*(th11*u2d+u2*th11d-(th12+th21)*uwd-uw*th12d+th22*w2d+w2*&
&     th22d-uw*th21d) + temp*rhod
    jxx = temp*rho
    temp = uw*th11 + u2*th12 - w2*th21 - uw*th22
    jxzd = rho*((th11-th22)*uwd+uw*th11d+th12*u2d+u2*th12d-th21*w2d-w2*&
&     th21d-uw*th22d) + temp*rhod
    jxz = temp*rho
    temp = uw*th11 - w2*th12 + u2*th21 - uw*th22
    jzxd = rho*((th11-th22)*uwd+uw*th11d-th12*w2d-w2*th12d+th21*u2d+u2*&
&     th21d-uw*th22d) + temp*rhod
    jzx = temp*rho
    temp = w2*th11 + uw*th12 + uw*th21 + u2*th22
    jzzd = rho*(th11*w2d+w2*th11d+(th12+th21)*uwd+uw*th12d+uw*th21d+th22&
&     *u2d+u2*th22d) + temp*rhod
    jzz = temp*rho
  END SUBROUTINE J_INNODE_D

  SUBROUTINE J_INNODE(th11, th12, th21, th22, u, w, rho, jxx, jxz, jzx, &
&   jzz)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: th11(4), th12(4), th21(4), th22(4), u(4), w(4)&
&   , rho(4)
    REAL*8, INTENT(OUT) :: jxx(4), jxz(4), jzx(4), jzz(4)
    REAL*8 :: u2(4), uw(4), w2(4)
    u2 = u**2
    uw = u*w
    w2 = w**2
    jxx = (u2*th11-uw*th12-uw*th21+w2*th22)*rho
    jxz = (uw*th11+u2*th12-w2*th21-uw*th22)*rho
    jzx = (uw*th11-w2*th12+u2*th21-uw*th22)*rho
    jzz = (w2*th11+uw*th12+uw*th21+u2*th22)*rho
  END SUBROUTINE J_INNODE

!  Differentiation of m_innode in forward (tangent) mode:
!   variations   of useful results: mz mx
!   with respect to varying inputs: u w deltastar_1 rho deltastar_2
  SUBROUTINE M_INNODE_D(deltastar_1, deltastar_1d, deltastar_2, &
&   deltastar_2d, u, ud, w, wd, rho, rhod, mx, mxd, mz, mzd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: deltastar_1(4), deltastar_2(4), u(4), w(4), &
&   rho(4)
    REAL*8, INTENT(IN) :: deltastar_1d(4), deltastar_2d(4), ud(4), wd(4)&
&   , rhod(4)
    REAL*8, INTENT(OUT) :: mx(4), mz(4)
    REAL*8, INTENT(OUT) :: mxd(4), mzd(4)
    REAL*8, DIMENSION(4) :: temp
    temp = deltastar_1*u + deltastar_2*w
    mxd = rho*(u*deltastar_1d+deltastar_1*ud+w*deltastar_2d+deltastar_2*&
&     wd) + temp*rhod
    mx = temp*rho
    temp = deltastar_2*u - deltastar_1*w
    mzd = rho*(u*deltastar_2d+deltastar_2*ud-w*deltastar_1d-deltastar_1*&
&     wd) + temp*rhod
    mz = temp*rho
  END SUBROUTINE M_INNODE_D

  SUBROUTINE M_INNODE(deltastar_1, deltastar_2, u, w, rho, mx, mz)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: deltastar_1(4), deltastar_2(4), u(4), w(4), &
&   rho(4)
    REAL*8, INTENT(OUT) :: mx(4), mz(4)
    mx = (deltastar_1*u+deltastar_2*w)*rho
    mz = (deltastar_2*u-deltastar_1*w)*rho
  END SUBROUTINE M_INNODE

!  Differentiation of e_innode in forward (tangent) mode:
!   variations   of useful results: ex ez
!   with respect to varying inputs: q u w thst1 thst2 rho
  SUBROUTINE E_INNODE_D(thst1, thst1d, thst2, thst2d, u, ud, w, wd, q, &
&   qd, rho, rhod, ex, exd, ez, ezd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: thst1(4), thst2(4), u(4), w(4), q(4), rho(4)
    REAL*8, INTENT(IN) :: thst1d(4), thst2d(4), ud(4), wd(4), qd(4), &
&   rhod(4)
    REAL*8, INTENT(OUT) :: ex(4), ez(4)
    REAL*8, INTENT(OUT) :: exd(4), ezd(4)
    REAL*8, DIMENSION(4) :: temp
    temp = thst1*u + thst2*w
    exd = temp*(q**2*rhod+rho*2*q*qd) + rho*q**2*(u*thst1d+thst1*ud+w*&
&     thst2d+thst2*wd)
    ex = rho*(q*q)*temp
    temp = thst2*u - thst1*w
    ezd = temp*(q**2*rhod+rho*2*q*qd) + rho*q**2*(u*thst2d+thst2*ud-w*&
&     thst1d-thst1*wd)
    ez = rho*(q*q)*temp
  END SUBROUTINE E_INNODE_D

  SUBROUTINE E_INNODE(thst1, thst2, u, w, q, rho, ex, ez)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: thst1(4), thst2(4), u(4), w(4), q(4), rho(4)
    REAL*8, INTENT(OUT) :: ex(4), ez(4)
    ex = rho*q**2*(thst1*u+thst2*w)
    ez = rho*q**2*(thst2*u-thst1*w)
  END SUBROUTINE E_INNODE

!  Differentiation of rhoq_innode in forward (tangent) mode:
!   variations   of useful results: rhoqx rhoqz
!   with respect to varying inputs: u w deltaprime_1 deltaprime_2
!                rho
  SUBROUTINE RHOQ_INNODE_D(deltaprime_1, deltaprime_1d, deltaprime_2, &
&   deltaprime_2d, u, ud, w, wd, rho, rhod, rhoqx, rhoqxd, rhoqz, rhoqzd&
& )
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: deltaprime_1(4), deltaprime_2(4), u(4), w(4), &
&   rho(4)
    REAL*8, INTENT(IN) :: deltaprime_1d(4), deltaprime_2d(4), ud(4), wd(&
&   4), rhod(4)
    REAL*8, INTENT(OUT) :: rhoqx(4), rhoqz(4)
    REAL*8, INTENT(OUT) :: rhoqxd(4), rhoqzd(4)
    REAL*8, DIMENSION(4) :: temp
    temp = deltaprime_1*u + deltaprime_2*w
    rhoqxd = temp*rhod + rho*(u*deltaprime_1d+deltaprime_1*ud+w*&
&     deltaprime_2d+deltaprime_2*wd)
    rhoqx = rho*temp
    temp = deltaprime_2*u - deltaprime_1*w
    rhoqzd = temp*rhod + rho*(u*deltaprime_2d+deltaprime_2*ud-w*&
&     deltaprime_1d-deltaprime_1*wd)
    rhoqz = rho*temp
  END SUBROUTINE RHOQ_INNODE_D

  SUBROUTINE RHOQ_INNODE(deltaprime_1, deltaprime_2, u, w, rho, rhoqx, &
&   rhoqz)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: deltaprime_1(4), deltaprime_2(4), u(4), w(4), &
&   rho(4)
    REAL*8, INTENT(OUT) :: rhoqx(4), rhoqz(4)
    rhoqx = rho*(deltaprime_1*u+deltaprime_2*w)
    rhoqz = rho*(deltaprime_2*u-deltaprime_1*w)
  END SUBROUTINE RHOQ_INNODE

!  Differentiation of tau_innode in forward (tangent) mode:
!   variations   of useful results: taux tauz
!   with respect to varying inputs: q u w cf_1 cf_2 rho
  SUBROUTINE TAU_INNODE_D(cf_1, cf_1d, cf_2, cf_2d, u, ud, w, wd, q, qd&
&   , rho, rhod, taux, tauxd, tauz, tauzd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: cf_1(4), cf_2(4), u(4), w(4), q(4), rho(4)
    REAL*8, INTENT(IN) :: cf_1d(4), cf_2d(4), ud(4), wd(4), qd(4), rhod(&
&   4)
    REAL*8, INTENT(OUT) :: taux(4), tauz(4)
    REAL*8, INTENT(OUT) :: tauxd(4), tauzd(4)
    REAL*8, DIMENSION(4) :: temp
    temp = cf_1*q*u + cf_2*q*w
    tauxd = temp*rhod/2 + rho*(u*(q*cf_1d+cf_1*qd)+cf_1*q*ud+w*(q*cf_2d+&
&     cf_2*qd)+cf_2*q*wd)/2
    taux = rho/2*temp
    temp = cf_2*q*u - cf_2*q*w
    tauzd = temp*rhod/2 + rho*(u*(q*cf_2d+cf_2*qd)+cf_2*q*ud-w*(q*cf_2d+&
&     cf_2*qd)-cf_2*q*wd)/2
    tauz = rho/2*temp
  END SUBROUTINE TAU_INNODE_D

  SUBROUTINE TAU_INNODE(cf_1, cf_2, u, w, q, rho, taux, tauz)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: cf_1(4), cf_2(4), u(4), w(4), q(4), rho(4)
    REAL*8, INTENT(OUT) :: taux(4), tauz(4)
    taux = rho*(cf_1*q*u+cf_2*q*w)/2
    tauz = rho*(cf_2*q*u-cf_2*q*w)/2
  END SUBROUTINE TAU_INNODE

!  Differentiation of mat3byvec in forward (tangent) mode:
!   variations   of useful results: z
!   with respect to varying inputs: x y z
  SUBROUTINE MAT3BYVEC_D(a, x, xd, y, yd, z, zd)
    IMPLICIT NONE
! custom subroutine for rank 3 matrix by vectors multiplication to improve performance of Tapenade differentiated
! code
    REAL*8, INTENT(IN) :: a(4, 4, 4), x(4), y(4)
    REAL*8, INTENT(IN) :: xd(4), yd(4)
    REAL*8, INTENT(INOUT) :: z(4)
    REAL*8, INTENT(INOUT) :: zd(4)
    REAL*8 :: interm(4)
    REAL*8 :: intermd(4)
    INTEGER :: i, j
    DO i=1,4
      interm=matmul(a(i, :, :), y)
      intermd=matmul(a(i, :, :), yd)
      z(i)=z(i)+dot_product(interm, x)
      zd(i)=zd(i)+dot_product(interm, xd)+dot_product(intermd, x)
    END DO
  END SUBROUTINE MAT3BYVEC_D

  SUBROUTINE MAT3BYVEC(a, x, y, z)
    IMPLICIT NONE
! custom subroutine for rank 3 matrix by vectors multiplication to improve performance of Tapenade differentiated
! code
    REAL*8, INTENT(IN) :: a(4, 4, 4), x(4), y(4)
    REAL*8, INTENT(INOUT) :: z(4)
    REAL*8 :: interm(4)
    INTEGER :: i, j
    DO i=1,4
      interm=matmul(a(i, :, :), y)
      z(i) = z(i) + dot_product(x, interm)
    END DO
  END SUBROUTINE MAT3BYVEC

!  Differentiation of cell_getresiduals in forward (tangent) mode:
!   variations   of useful results: rmass rts rmomx rmomz ren
!   with respect to varying inputs: h rmass n nts qx qy qz rts
!                th11 beta rmomx rmomz ren
  SUBROUTINE CELL_GETRESIDUALS_D(n, nd, th11, th11d, h, hd, beta, betad&
&   , nts, ntsd, qx, qxd, qy, qyd, qz, qzd, rho0, v_sonic, a_transition&
&   , a_rethcrit, mtosys, uinf, mu, ncrit, gamma, rvj, rdxj, rdyj, rudxj&
&   , rudyj, rmass, rmassd, rmomx, rmomxd, rmomz, rmomzd, ren, rend, rts&
&   , rtsd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: n(4), th11(4), h(4), beta(4), nts(4), qx(4), &
&   qy(4), qz(4)
    REAL*8, INTENT(IN) :: nd(4), th11d(4), hd(4), betad(4), ntsd(4), qxd&
&   (4), qyd(4), qzd(4)
    REAL*8, INTENT(IN) :: rho0, v_sonic, a_transition, a_rethcrit, &
&   mtosys(3, 3), uinf, mu, ncrit, gamma, rvj(4, 4), rdxj(4, 4), rdyj(4&
&   , 4), rudxj(4, 4, 4), rudyj(4, 4, 4)
    REAL*8, INTENT(OUT) :: rmass(4), rmomx(4), rmomz(4), ren(4), rts(4)
    REAL*8, INTENT(OUT) :: rmassd(4), rmomxd(4), rmomzd(4), rend(4), &
&   rtsd(4)
! residual matrixes: rows for residual number
    REAL*8 :: qe(4), u(4), w(4), m(4), rho(4), rth(4), hk(4), p(4), sgn(&
&   4), cl(4), ct(4), cf(4), f(4), a_cr(4), cf_cr(4), hst(4), hpr(4), cd&
&   (4), cd_cr(4), taux(4), tauz(4), d(4), dst1(4), dst2(4), th12(4), &
&   th21(4), th22(4), dpr1(4), dpr2(4), thst1(4), thst2(4), jxx(4), jxz(&
&   4), jzx(4), jzz(4), mx(4), mz(4), ex(4), ez(4), rhoqx(4), rhoqz(4)
    REAL*8 :: qed(4), ud(4), wd(4), md(4), rhod(4), rthd(4), hkd(4), pd(&
&   4), sgnd(4), cld(4), ctd(4), cfd(4), fd(4), a_crd(4), cf_crd(4), &
&   hstd(4), hprd(4), cdd(4), cd_crd(4), tauxd(4), tauzd(4), dd(4), &
&   dst1d(4), dst2d(4), th12d(4), th21d(4), th22d(4), dpr1d(4), dpr2d(4)&
&   , thst1d(4), thst2d(4), jxxd(4), jxzd(4), jzxd(4), jzzd(4), mxd(4), &
&   mzd(4), exd(4), ezd(4), rhoqxd(4), rhoqzd(4)
    INTRINSIC TAN
    REAL*8, DIMENSION(4) :: temp
    CALL UWQ_D(qx, qxd, qy, qyd, qz, qzd, mtosys, u, ud, w, wd, qe, qed)
    CALL MACHE_D(qe, qed, v_sonic, m, md)
    CALL RHOE_D(m, md, v_sonic, rho0, uinf, rho, rhod)
    CALL RETH_D(qe, qed, rho, rhod, th11, th11d, mu, rth, rthd)
    CALL HK_CLOSURE_D(h, hd, m, md, hk, hkd)
    CALL P_TRANS_D(rth, rthd, hk, hkd, th11, th11d, a_rethcrit, p, pd)
    CALL SIGMA_N_D(nts, ntsd, ncrit, a_transition, sgn, sgnd)
    CALL FC_D(m, md, gamma, f, fd)
! closure relationships
    CALL CF_LAMINAR_D(hk, hkd, rth, rthd, cl, cld)
    CALL CF_TURBULENT_D(hk, hkd, rth, rthd, f, fd, ct, ctd)
    cfd = (ct-cl)*sgnd + sgn*ctd + (1.0-sgn)*cld
    cf = sgn*ct + (1.0-sgn)*cl
    CALL A_CROSSFLOW_D(cf, cfd, beta, betad, m, md, a_cr, a_crd)
    temp = TAN(beta)
    cf_crd = -(temp*cfd+cf*(1.0+TAN(beta)**2)*betad)
    cf_cr = -(cf*temp)
    CALL HSTAR_LAMINAR_D(hk, hkd, cl, cld)
    CALL HSTAR_TURBULENT_D(hk, hkd, m, md, ct, ctd)
    hstd = (ct-cl)*sgnd + sgn*ctd + (1.0-sgn)*cld
    hst = sgn*ct + (1.0-sgn)*cl
    CALL HPRIME_LAMINAR_D(m, md, hk, hkd, cl, cld)
    CALL HPRIME_TURBULENT_D(m, md, hk, hkd, ct, ctd)
    hprd = (ct-cl)*sgnd + sgn*ctd + (1.0-sgn)*cld
    hpr = sgn*ct + (1.0-sgn)*cl
    CALL CD_LAMINAR_D(hst, hstd, hk, hkd, rth, rthd, cl, cld)
    CALL CD_TURBULENT_D(hk, hkd, f, fd, m, md, rth, rthd, ct, ctd)
    cdd = (ct-cl)*sgnd + sgn*ctd + (1.0-sgn)*cld
    cd = sgn*ct + (1.0-sgn)*cl
    CALL CD_INNODE_D(cd, cdd, a_cr, a_crd, cd_cr, cd_crd)
    dd = rho*(cd+cd_cr)*3*qe**2*qed + qe**3*((cd+cd_cr)*rhod+rho*(cdd+&
&     cd_crd))
    d = rho*qe**3*(cd+cd_cr)
    CALL TAU_INNODE_D(cf, cfd, cf_cr, cf_crd, u, ud, w, wd, qe, qed, rho&
&               , rhod, taux, tauxd, tauz, tauzd)
    CALL DELTASTAR_INNODE_D(th11, th11d, h, hd, a_cr, a_crd, dst1, dst1d&
&                     , dst2, dst2d)
    CALL THETA_INNODE_D(th11, th11d, a_cr, a_crd, dst2, dst2d, th12, &
&                 th12d, th21, th21d, th22, th22d)
    CALL DELTAPRIME_INNODE_D(hpr, hprd, a_cr, a_crd, th11, th11d, dpr1, &
&                      dpr1d, dpr2, dpr2d)
    CALL THETASTAR_INNODE_D(hst, hstd, a_cr, a_crd, dst1, dst1d, th11, &
&                     th11d, th22, th22d, thst1, thst1d, thst2, thst2d)
    CALL J_INNODE_D(th11, th11d, th12, th12d, th21, th21d, th22, th22d, &
&             u, ud, w, wd, rho, rhod, jxx, jxxd, jxz, jxzd, jzx, jzxd, &
&             jzz, jzzd)
    CALL M_INNODE_D(dst1, dst1d, dst2, dst2d, u, ud, w, wd, rho, rhod, &
&             mx, mxd, mz, mzd)
    CALL E_INNODE_D(thst1, thst1d, thst2, thst2d, u, ud, w, wd, qe, qed&
&             , rho, rhod, ex, exd, ez, ezd)
    CALL RHOQ_INNODE_D(dpr1, dpr1d, dpr2, dpr2d, u, ud, w, wd, rho, rhod&
&                , rhoqx, rhoqxd, rhoqz, rhoqzd)
    rmomx=0.0_8
    rmomxd=0.0_8
    rmomx=rmomx+matmul(rdxj, jxx)
    rmomxd=rmomxd+matmul(rdxj, jxxd)
    rmomx=rmomx+matmul(rdyj, jxz)
    rmomxd=rmomxd+matmul(rdyj, jxzd)
    rmomx=rmomx+matmul(rvj, -taux)
    rmomxd=rmomxd+matmul(rvj, -tauxd)
    CALL MAT3BYVEC_D(rudxj, mx, mxd, u, ud, rmomx, rmomxd)
    CALL MAT3BYVEC_D(rudyj, mz, mzd, u, ud, rmomx, rmomxd)
    rmomz=0.0_8
    rmomzd=0.0_8
    rmomz=rmomz+matmul(rdxj, jzx)
    rmomzd=rmomzd+matmul(rdxj, jzxd)
    rmomz=rmomz+matmul(rdyj, jzz)
    rmomzd=rmomzd+matmul(rdyj, jzzd)
    rmomz=rmomz+matmul(rvj, -tauz)
    rmomzd=rmomzd+matmul(rvj, -tauzd)
    CALL MAT3BYVEC_D(rudxj, mx, mxd, w, wd, rmomz, rmomzd)
    CALL MAT3BYVEC_D(rudyj, mz, mzd, w, wd, rmomz, rmomzd)
    ren=0.0_8
    rend=0.0_8
    ren=ren+matmul(rdxj, ex)
    rend=rend+matmul(rdxj, exd)
    ren=ren+matmul(rdyj, ez)
    rend=rend+matmul(rdyj, ezd)
    ren=ren+matmul(rvj, -2*d)
    rend=rend+matmul(rvj, -2*dd)
    CALL MAT3BYVEC_D(rudxj, rhoqx, rhoqxd, qe**2, 2*qe*qed, ren, rend)
    CALL MAT3BYVEC_D(rudyj, rhoqz, rhoqzd, qe**2, 2*qe*qed, ren, rend)
    rts=0.0_8
    rtsd=0.0_8
    CALL MAT3BYVEC_D(rudxj, u, ud, nts, ntsd, rts, rtsd)
    CALL MAT3BYVEC_D(rudyj, w, wd, nts, ntsd, rts, rtsd)
    rts=rts+matmul(rvj, -(qe*p))
    rtsd=rtsd+matmul(rvj, -(qe*pd+qed*p))
    rmass=0.0_8
    rmassd=0.0_8
    rmass=rmass+matmul(rdxj, mx)
    rmassd=rmassd+matmul(rdxj, mxd)
    rmass=rmass+matmul(rdyj, mz)
    rmassd=rmassd+matmul(rdyj, mzd)
    rmass=rmass+matmul(rvj, -rho*n)
    rmassd=rmassd+matmul(rvj, -(rhod*n+rho*nd))
  END SUBROUTINE CELL_GETRESIDUALS_D

  SUBROUTINE CELL_GETRESIDUALS(n, th11, h, beta, nts, qx, qy, qz, rho0, &
&   v_sonic, a_transition, a_rethcrit, mtosys, uinf, mu, ncrit, gamma, &
&   rvj, rdxj, rdyj, rudxj, rudyj, rmass, rmomx, rmomz, ren, rts)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: n(4), th11(4), h(4), beta(4), nts(4), qx(4), &
&   qy(4), qz(4)
    REAL*8, INTENT(IN) :: rho0, v_sonic, a_transition, a_rethcrit, &
&   mtosys(3, 3), uinf, mu, ncrit, gamma, rvj(4, 4), rdxj(4, 4), rdyj(4&
&   , 4), rudxj(4, 4, 4), rudyj(4, 4, 4)
    REAL*8, INTENT(OUT) :: rmass(4), rmomx(4), rmomz(4), ren(4), rts(4)
! residual matrixes: rows for residual number
    REAL*8 :: qe(4), u(4), w(4), m(4), rho(4), rth(4), hk(4), p(4), sgn(&
&   4), cl(4), ct(4), cf(4), f(4), a_cr(4), cf_cr(4), hst(4), hpr(4), cd&
&   (4), cd_cr(4), taux(4), tauz(4), d(4), dst1(4), dst2(4), th12(4), &
&   th21(4), th22(4), dpr1(4), dpr2(4), thst1(4), thst2(4), jxx(4), jxz(&
&   4), jzx(4), jzz(4), mx(4), mz(4), ex(4), ez(4), rhoqx(4), rhoqz(4)
    INTRINSIC TAN
    CALL UWQ(qx, qy, qz, mtosys, u, w, qe)
    CALL MACHE(qe, v_sonic, m)
    CALL RHOE(m, v_sonic, rho0, uinf, rho)
    CALL RETH(qe, rho, th11, mu, rth)
    CALL HK_CLOSURE(h, m, hk)
    CALL P_TRANS(rth, hk, th11, a_rethcrit, p)
    CALL SIGMA_N(nts, ncrit, a_transition, sgn)
    CALL FC(m, gamma, f)
! closure relationships
    CALL CF_LAMINAR(hk, rth, cl)
    CALL CF_TURBULENT(hk, rth, f, ct)
    cf = sgn*ct + (1.0-sgn)*cl
    CALL A_CROSSFLOW(cf, beta, m, a_cr)
    cf_cr = -(cf*TAN(beta))
    CALL HSTAR_LAMINAR(hk, cl)
    CALL HSTAR_TURBULENT(hk, m, ct)
    hst = sgn*ct + (1.0-sgn)*cl
    CALL HPRIME_LAMINAR(m, hk, cl)
    CALL HPRIME_TURBULENT(m, hk, ct)
    hpr = sgn*ct + (1.0-sgn)*cl
    CALL CD_LAMINAR(hst, hk, rth, cl)
    CALL CD_TURBULENT(hk, f, m, rth, ct)
    cd = sgn*ct + (1.0-sgn)*cl
    CALL CD_INNODE(cd, a_cr, cd_cr)
    d = rho*qe**3*(cd+cd_cr)
    CALL TAU_INNODE(cf, cf_cr, u, w, qe, rho, taux, tauz)
    CALL DELTASTAR_INNODE(th11, h, a_cr, dst1, dst2)
    CALL THETA_INNODE(th11, a_cr, dst2, th12, th21, th22)
    CALL DELTAPRIME_INNODE(hpr, a_cr, th11, dpr1, dpr2)
    CALL THETASTAR_INNODE(hst, a_cr, dst1, th11, th22, thst1, thst2)
    CALL J_INNODE(th11, th12, th21, th22, u, w, rho, jxx, jxz, jzx, jzz)
    CALL M_INNODE(dst1, dst2, u, w, rho, mx, mz)
    CALL E_INNODE(thst1, thst2, u, w, qe, rho, ex, ez)
    CALL RHOQ_INNODE(dpr1, dpr2, u, w, rho, rhoqx, rhoqz)
    rmomx=0.0_8
    rmomx=rmomx+matmul(rdxj, jxx)
    rmomx=rmomx+matmul(rdyj, jxz)
    rmomx=rmomx+matmul(rvj, -taux)
    CALL MAT3BYVEC(rudxj, mx, u, rmomx)
    CALL MAT3BYVEC(rudyj, mz, u, rmomx)
    rmomz=0.0_8
    rmomz=rmomz+matmul(rdxj, jzx)
    rmomz=rmomz+matmul(rdyj, jzz)
    rmomz=rmomz+matmul(rvj, -tauz)
    CALL MAT3BYVEC(rudxj, mx, w, rmomz)
    CALL MAT3BYVEC(rudyj, mz, w, rmomz)
    ren=0.0_8
    ren=ren+matmul(rdxj, ex)
    ren=ren+matmul(rdyj, ez)
    ren=ren+matmul(rvj, -2*d)
    CALL MAT3BYVEC(rudxj, rhoqx, qe**2, ren)
    CALL MAT3BYVEC(rudyj, rhoqz, qe**2, ren)
    rts=0.0_8
    CALL MAT3BYVEC(rudxj, u, nts, rts)
    CALL MAT3BYVEC(rudyj, w, nts, rts)
    rts=rts+matmul(rvj, -(qe*p))
    rmass=0.0_8
    rmass=rmass+matmul(rdxj, mx)
    rmass=rmass+matmul(rdyj, mz)
    rmass=rmass+matmul(rvj, -rho*n)
  END SUBROUTINE CELL_GETRESIDUALS

!  Differentiation of mesh_getresiduals in forward (tangent) mode:
!   variations   of useful results: rmass rts rmomx rmomz ren
!   with respect to varying inputs: h n nts qx qy qz th11 beta
!   RW status of diff variables: h:in rmass:out n:in nts:in qx:in
!                qy:in qz:in rts:out th11:in beta:in rmomx:out
!                rmomz:out ren:out
  SUBROUTINE MESH_GETRESIDUALS_D(nnodes, ncells, cellmat, n, nd, th11, &
&   th11d, h, hd, beta, betad, nts, ntsd, qx, qxd, qy, qyd, qz, qzd, &
&   rho0, v_sonic, a_transition, a_rethcrit, mtosys, uinf, mu, ncrit, &
&   gamma, rvj, rdxj, rdyj, rudxj, rudyj, rmass, rmassd, rmomx, rmomxd, &
&   rmomz, rmomzd, ren, rend, rts, rtsd)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nnodes, ncells
    INTEGER, INTENT(IN) :: cellmat(ncells, 4)
    REAL*8, INTENT(IN) :: n(nnodes), th11(nnodes), h(nnodes), beta(&
&   nnodes), nts(nnodes), qx(nnodes), qy(nnodes), qz(nnodes), rho0, &
&   v_sonic, a_transition, a_rethcrit, mtosys(ncells, 3, 3), uinf, mu, &
&   ncrit, gamma, rvj(ncells, 4, 4), rdxj(ncells, 4, 4), rdyj(ncells, 4&
&   , 4), rudxj(ncells, 4, 4, 4), rudyj(ncells, 4, 4, 4)
    REAL*8, INTENT(IN) :: nd(nnodes), th11d(nnodes), hd(nnodes), betad(&
&   nnodes), ntsd(nnodes), qxd(nnodes), qyd(nnodes), qzd(nnodes)
    REAL*8, INTENT(OUT) :: rmass(nnodes), rmomx(nnodes), rmomz(nnodes), &
&   ren(nnodes), rts(nnodes)
    REAL*8, INTENT(OUT) :: rmassd(nnodes), rmomxd(nnodes), rmomzd(nnodes&
&   ), rend(nnodes), rtsd(nnodes)
    INTEGER :: i, inds(4)
    REAL*8 :: rmass_l(4), rmomx_l(4), rmomz_l(4), ren_l(4), rts_l(4)
    REAL*8 :: rmass_ld(4), rmomx_ld(4), rmomz_ld(4), ren_ld(4), rts_ld(4&
&   )
    rmass = 0.0
    rmomx = 0.0
    rmomz = 0.0
    ren = 0.0
    rts = 0.0
    rmassd = 0.0_8
    rtsd = 0.0_8
    rmomxd = 0.0_8
    rmomzd = 0.0_8
    rend = 0.0_8
    rmomx_ld = 0.0_8
    rts_ld = 0.0_8
    rmomz_ld = 0.0_8
    ren_ld = 0.0_8
    rmass_ld = 0.0_8
    DO i=1,ncells
      inds = cellmat(i, :)

      rmomx_ld = 0.0_8
      rts_ld = 0.0_8
      rmomz_ld = 0.0_8
      ren_ld = 0.0_8
      rmass_ld = 0.0_8

      CALL CELL_GETRESIDUALS_D(n(inds), nd(inds), th11(inds), th11d(inds&
&                        ), h(inds), hd(inds), beta(inds), betad(inds), &
&                        nts(inds), ntsd(inds), qx(inds), qxd(inds), qy(&
&                        inds), qyd(inds), qz(inds), qzd(inds), rho0, &
&                        v_sonic, a_transition, a_rethcrit, mtosys(i, :&
&                        , :), uinf, mu, ncrit, gamma, rvj(i, :, :), &
&                        rdxj(i, :, :), rdyj(i, :, :), rudxj(i, :, :, :)&
&                        , rudyj(i, :, :, :), rmass_l, rmass_ld, rmomx_l&
&                        , rmomx_ld, rmomz_l, rmomz_ld, ren_l, ren_ld, &
&                        rts_l, rts_ld)
      rmassd(inds) = rmassd(inds) + rmass_ld
      rmass(inds) = rmass(inds) + rmass_l
      rmomxd(inds) = rmomxd(inds) + rmomx_ld
      rmomx(inds) = rmomx(inds) + rmomx_l
      rmomzd(inds) = rmomzd(inds) + rmomz_ld
      rmomz(inds) = rmomz(inds) + rmomz_l
      rend(inds) = rend(inds) + ren_ld
      ren(inds) = ren(inds) + ren_l
      rtsd(inds) = rtsd(inds) + rts_ld
      rts(inds) = rts(inds) + rts_l
    END DO
  END SUBROUTINE MESH_GETRESIDUALS_D

  SUBROUTINE MESH_GETRESIDUALS(nnodes, ncells, cellmat, n, th11, h, beta&
&   , nts, qx, qy, qz, rho0, v_sonic, a_transition, a_rethcrit, mtosys, &
&   uinf, mu, ncrit, gamma, rvj, rdxj, rdyj, rudxj, rudyj, rmass, rmomx&
&   , rmomz, ren, rts)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nnodes, ncells
    INTEGER, INTENT(IN) :: cellmat(ncells, 4)
    REAL*8, INTENT(IN) :: n(nnodes), th11(nnodes), h(nnodes), beta(&
&   nnodes), nts(nnodes), qx(nnodes), qy(nnodes), qz(nnodes), rho0, &
&   v_sonic, a_transition, a_rethcrit, mtosys(ncells, 3, 3), uinf, mu, &
&   ncrit, gamma, rvj(ncells, 4, 4), rdxj(ncells, 4, 4), rdyj(ncells, 4&
&   , 4), rudxj(ncells, 4, 4, 4), rudyj(ncells, 4, 4, 4)
    REAL*8, INTENT(OUT) :: rmass(nnodes), rmomx(nnodes), rmomz(nnodes), &
&   ren(nnodes), rts(nnodes)
    INTEGER :: i, inds(4)
    REAL*8 :: rmass_l(4), rmomx_l(4), rmomz_l(4), ren_l(4), rts_l(4)
    rmass = 0.0
    rmomx = 0.0
    rmomz = 0.0
    ren = 0.0
    rts = 0.0
    DO i=1,ncells
      inds = cellmat(i, :)
      CALL CELL_GETRESIDUALS(n(inds), th11(inds), h(inds), beta(inds), &
&                      nts(inds), qx(inds), qy(inds), qz(inds), rho0, &
&                      v_sonic, a_transition, a_rethcrit, mtosys(i, :, :&
&                      ), uinf, mu, ncrit, gamma, rvj(i, :, :), rdxj(i, &
&                      :, :), rdyj(i, :, :), rudxj(i, :, :, :), rudyj(i&
&                      , :, :, :), rmass_l, rmomx_l, rmomz_l, ren_l, &
&                      rts_l)
      rmass(inds) = rmass(inds) + rmass_l
      rmomx(inds) = rmomx(inds) + rmomx_l
      rmomz(inds) = rmomz(inds) + rmomz_l
      ren(inds) = ren(inds) + ren_l
      rts(inds) = rts(inds) + rts_l
    END DO
  END SUBROUTINE MESH_GETRESIDUALS

END MODULE THREE_EQUATION_D

